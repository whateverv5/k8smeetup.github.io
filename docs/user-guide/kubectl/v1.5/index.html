<!DOCTYPE html><html>
<head>
<meta charset="UTF-8">

<title>Kubectl 参考文档</title>
<link rel="shortcut icon" href="favicon.ico" type="image/vnd.microsoft.icon">

<link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="node_modules/highlight.js/styles/default.css" type="text/css">
<link rel="stylesheet" href="stylesheet.css" type="text/css">
</head>

<body>

<div id="sidebar-wrapper" class="side-nav side-bar-nav"><ul><li class="nav-level-1 strong-nav"><a href="#-strong-getting-started-strong-" class="nav-item"><strong>入门指南</strong></a></li></ul><ul><li class="nav-level-1"><a href="#run" class="nav-item">run</a></li></ul><ul><li class="nav-level-1"><a href="#expose" class="nav-item">expose</a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-app-management-strong-" class="nav-item"><strong>API 管理</strong></a></li></ul><ul><li class="nav-level-1"><a href="#annotate" class="nav-item">annotate</a></li></ul><ul><li class="nav-level-1"><a href="#autoscale" class="nav-item">autoscale</a></li></ul><ul><li class="nav-level-1"><a href="#convert" class="nav-item">convert</a></li></ul><ul><li class="nav-level-1"><a href="#create" class="nav-item">create</a></li><ul id="create-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-configmap-em-" class="nav-item"><em>configmap</em></a></li><li class="nav-level-2"><a href="#-em-deployment-em-" class="nav-item"><em>deployment</em></a></li><li class="nav-level-2"><a href="#-em-namespace-em-" class="nav-item"><em>namespace</em></a></li><li class="nav-level-2"><a href="#-em-quota-em-" class="nav-item"><em>quota</em></a></li><li class="nav-level-2"><a href="#-em-secret-em-" class="nav-item"><em>secret</em></a></li><li class="nav-level-2"><a href="#-em-secret-docker-registry-em-" class="nav-item"><em>secret docker-registry</em></a></li><li class="nav-level-2"><a href="#-em-secret-generic-em-" class="nav-item"><em>secret generic</em></a></li><li class="nav-level-2"><a href="#-em-secret-tls-em-" class="nav-item"><em>secret tls</em></a></li><li class="nav-level-2"><a href="#-em-service-em-" class="nav-item"><em>service</em></a></li><li class="nav-level-2"><a href="#-em-service-clusterip-em-" class="nav-item"><em>service clusterip</em></a></li><li class="nav-level-2"><a href="#-em-service-loadbalancer-em-" class="nav-item"><em>service loadbalancer</em></a></li><li class="nav-level-2"><a href="#-em-service-nodeport-em-" class="nav-item"><em>service nodeport</em></a></li><li class="nav-level-2"><a href="#-em-serviceaccount-em-" class="nav-item"><em>serviceaccount</em></a></li></ul></ul><ul><li class="nav-level-1"><a href="#delete" class="nav-item">delete</a></li></ul><ul><li class="nav-level-1"><a href="#edit" class="nav-item">edit</a></li></ul><ul><li class="nav-level-1"><a href="#get" class="nav-item">get</a></li></ul><ul><li class="nav-level-1"><a href="#label" class="nav-item">label</a></li></ul><ul><li class="nav-level-1"><a href="#patch" class="nav-item">patch</a></li></ul><ul><li class="nav-level-1"><a href="#replace" class="nav-item">replace</a></li></ul><ul><li class="nav-level-1"><a href="#rolling-update" class="nav-item">rolling-update</a></li></ul><ul><li class="nav-level-1"><a href="#rollout" class="nav-item">rollout</a></li><ul id="rollout-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-history-em-" class="nav-item"><em>history</em></a></li><li class="nav-level-2"><a href="#-em-pause-em-" class="nav-item"><em>pause</em></a></li><li class="nav-level-2"><a href="#-em-resume-em-" class="nav-item"><em>resume</em></a></li><li class="nav-level-2"><a href="#-em-status-em-" class="nav-item"><em>status</em></a></li><li class="nav-level-2"><a href="#-em-undo-em-" class="nav-item"><em>undo</em></a></li></ul></ul><ul><li class="nav-level-1"><a href="#scale" class="nav-item">scale</a></li></ul><ul><li class="nav-level-1"><a href="#set" class="nav-item">set</a></li><ul id="set-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-image-em-" class="nav-item"><em>image</em></a></li><li class="nav-level-2"><a href="#-em-resources-em-" class="nav-item"><em>resources</em></a></li></ul></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-declarative-app-management-strong-" class="nav-item"><strong>声明 APP 管理</strong></a></li></ul><ul><li class="nav-level-1"><a href="#apply" class="nav-item">apply</a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-working-with-apps-strong-" class="nav-item"><strong>使用 APP 程序</strong></a></li></ul><ul><li class="nav-level-1"><a href="#attach" class="nav-item">attach</a></li></ul><ul><li class="nav-level-1"><a href="#cp" class="nav-item">cp</a></li></ul><ul><li class="nav-level-1"><a href="#describe" class="nav-item">describe</a></li></ul><ul><li class="nav-level-1"><a href="#exec" class="nav-item">exec</a></li></ul><ul><li class="nav-level-1"><a href="#logs" class="nav-item">logs</a></li></ul><ul><li class="nav-level-1"><a href="#port-forward" class="nav-item">port-forward</a></li></ul><ul><li class="nav-level-1"><a href="#proxy" class="nav-item">proxy</a></li></ul><ul><li class="nav-level-1"><a href="#top" class="nav-item">top</a></li><ul id="top-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-node-em-" class="nav-item"><em>node</em></a></li><li class="nav-level-2"><a href="#-em-pod-em-" class="nav-item"><em>pod</em></a></li></ul></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-cluster-management-strong-" class="nav-item"><strong>集群管理</strong></a></li></ul><ul><li class="nav-level-1"><a href="#api-versions" class="nav-item">api-versions</a></li></ul><ul><li class="nav-level-1"><a href="#certificate" class="nav-item">certificate</a></li><ul id="certificate-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-approve-em-" class="nav-item"><em>approve</em></a></li><li class="nav-level-2"><a href="#-em-deny-em-" class="nav-item"><em>deny</em></a></li></ul></ul><ul><li class="nav-level-1"><a href="#cluster-info" class="nav-item">cluster-info</a></li><ul id="cluster-info-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-dump-em-" class="nav-item"><em>dump</em></a></li></ul></ul><ul><li class="nav-level-1"><a href="#cordon" class="nav-item">cordon</a></li></ul><ul><li class="nav-level-1"><a href="#drain" class="nav-item">drain</a></li></ul><ul><li class="nav-level-1"><a href="#taint" class="nav-item">taint</a></li></ul><ul><li class="nav-level-1"><a href="#uncordon" class="nav-item">uncordon</a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-kubectl-settings-and-usage-strong-" class="nav-item"><strong>KUBECTL 配置使用</strong></a></li></ul><ul><li class="nav-level-1"><a href="#completion" class="nav-item">completion</a></li></ul><ul><li class="nav-level-1"><a href="#config" class="nav-item">config</a></li><ul id="config-nav" style="display: none;"><li class="nav-level-2"><a href="#-em-current-context-em-" class="nav-item"><em>current-context</em></a></li><li class="nav-level-2"><a href="#-em-delete-cluster-em-" class="nav-item"><em>delete-cluster</em></a></li><li class="nav-level-2"><a href="#-em-delete-context-em-" class="nav-item"><em>delete-context</em></a></li><li class="nav-level-2"><a href="#-em-get-clusters-em-" class="nav-item"><em>get-clusters</em></a></li><li class="nav-level-2"><a href="#-em-get-contexts-em-" class="nav-item"><em>get-contexts</em></a></li><li class="nav-level-2"><a href="#-em-set-em-" class="nav-item"><em>set</em></a></li><li class="nav-level-2"><a href="#-em-set-cluster-em-" class="nav-item"><em>set-cluster</em></a></li><li class="nav-level-2"><a href="#-em-set-context-em-" class="nav-item"><em>set-context</em></a></li><li class="nav-level-2"><a href="#-em-set-credentials-em-" class="nav-item"><em>set-credentials</em></a></li><li class="nav-level-2"><a href="#-em-unset-em-" class="nav-item"><em>unset</em></a></li><li class="nav-level-2"><a href="#-em-use-context-em-" class="nav-item"><em>use-context</em></a></li><li class="nav-level-2"><a href="#-em-view-em-" class="nav-item"><em>view</em></a></li></ul></ul><ul><li class="nav-level-1"><a href="#explain" class="nav-item">explain</a></li></ul><ul><li class="nav-level-1"><a href="#options" class="nav-item">options</a></li></ul><ul><li class="nav-level-1"><a href="#version" class="nav-item">version</a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-deprecated-commands-strong-" class="nav-item"><strong>弃用命令</strong></a></li></ul><ul><li class="nav-level-1"><a href="#stop" class="nav-item">stop</a></li></ul><br/><div class="copyright"><a href="https://github.com/kubernetes/kubernetes">Copyright 2016 The Kubernetes Authors.</a></div></div>

<div id="wrapper">
<div id="code-tabs-wrapper" class="code-tabs"><ul class="code-tab-list"><li class="code-tab" id="example">举例</li></ul></div>
<div id="page-content-wrapper" class="body-content container-fluid"><h1 id="-strong-getting-started-strong-"><strong>入门指南</strong></h1>
<p>本节包含用于在集群上运行工作负载的最基本命令 .</p>
<ul>
<li><code>run</code> 将开始在集群上运行一个或多个容器映像的实例 .</li>
<li><code>expose</code> 将负载平衡运行实例的流量，并且可以创建一个HA代理，用于从群集外部访问容器 .</li>
</ul>
<p>一旦您的工作负载正在运行，您可以使用
<a href="#-strong-working-with-apps-strong-">使用应用程序</a> 部分中的命令来检查它们</p>
<hr>
<h1 id="run">run</h1>
<blockquote class="code-block example">
<p> 启动一个单一 nginx 实例.</p>
</blockquote> 
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> nginx <span class="hljs-comment">--image=nginx</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动一个单一的 hazelcast 实例，让容器暴露5701端口.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> hazelcast <span class="hljs-comment">--image=hazelcast --port=5701</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动一个单一的 hazelcast 实例，并在容器中设置环境变量 “DNS_DOMAIN = cluster” 和 “POD_NAMESPACE =default”. </p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl run hazelcast --<span class="hljs-keyword">image</span>=hazelcast --<span class="hljs-keyword">env</span>=<span class="hljs-string">"DNS_DOMAIN=cluster"</span> --<span class="hljs-keyword">env</span>=<span class="hljs-string">"POD_NAMESPACE=default"</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动一个复制的 nginx 实例.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> nginx <span class="hljs-comment">--image=nginx --replicas=5</span>
</code></pre>
<blockquote class="code-block example">
<p> 空运行.打印相应的 API 对象而不创建它们.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> nginx --<span class="hljs-built_in">image</span>=nginx --dry-<span class="hljs-built_in">run</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动一个单一的 nginx 实例，但是使用从 JSON 分析的一部分值来重载部署规格.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">run </span><span class="hljs-string">nginx </span><span class="hljs-built_in">--image=nginx</span> <span class="hljs-built_in">--overrides='{</span> <span class="hljs-string">"apiVersion"</span>: <span class="hljs-string">"v1"</span>, <span class="hljs-string">"spec"</span>: { ... } }<span class="hljs-string">'</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动一个 busybox 的 pod 并将其保留在前台，如果它退出，请不要重新启动它.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> -i -t busybox <span class="hljs-comment">--image=busybox --restart=Never</span>
</code></pre>
<blockquote class="code-block example">
<p> 使用默认命令启动 nginx 容器，但对该命令使用自定义参数（arg1 .. argN）.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl run nginx --image=nginx -- <span class="hljs-tag">&lt;<span class="hljs-name">arg1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">arg2</span>&gt;</span> ... <span class="hljs-tag">&lt;<span class="hljs-name">argN</span>&gt;</span>
</code></pre>
<blockquote class="code-block example">
<p> 使用不同的命令和自定义参数启动 nginx 容器.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl run nginx --image=nginx --<span class="hljs-keyword">command</span> -- <span class="hljs-symbol">&lt;cmd&gt;</span> <span class="hljs-symbol">&lt;arg1&gt;</span> ... <span class="hljs-symbol">&lt;argN&gt;</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动 perl 容器来计算 π 后2000位并打印出来.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> <span class="hljs-literal">pi</span> <span class="hljs-comment">--image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'</span>
</code></pre>
<blockquote class="code-block example">
<p> 启动 cron 作业计算 π 后2000位，每5分钟打印一次.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">run</span> pi --schedule=<span class="hljs-string">"0/5 * * * ?"</span> --<span class="hljs-built_in">image</span>=perl --restart=OnFailure -- perl -Mbignum=bpi -wle <span class="hljs-string">'print bpi(2000)'</span>
</code></pre>
<p>创建并运行可能复制的特定图像.</p>
<p>创建 deployment 或 job 来管理创建的容器.</p>
<h3 id="usage">用法</h3>
<p><code>$ run NAME --image=image [--env=&quot;key=value&quot;] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>attach</td>
<td></td>
<td>false</td>
<td>如果为 true，请等待 Pod 开始运行，然后连接到 Pod，就像调用 “kubectl attach ...” 一样. 默认为 false，除非设置了 “-i / - stdin”，否则默认为 true. 使用 '--restart = Never' 返回容器进程的退出代码.</td>
</tr>
<tr>
<td>command</td>
<td></td>
<td>false</td>
<td>如果存在 true 和额外的参数，则将它们用作容器中的 “command” 字段，而不是默认的 “args” 字段.</td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送.</td>
</tr>
<tr>
<td>env</td>
<td></td>
<td>[]</td>
<td>在容器中设置的环境变量.</td>
</tr>
<tr>
<td>expose</td>
<td></td>
<td>false</td>
<td>如果为 true，则为运行的容器创建一个公共的外部服务.</td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td></td>
<td>要使用的 API 生成器的名称，请参阅 <a href="http://kubernetes.io/docs/user-guide/kubectl-conventions/#generators">http://kubernetes.io/docs/user-guide/kubectl-conventions/#generators</a> 列表.</td>
</tr>
<tr>
<td>hostport</td>
<td></td>
<td>-1</td>
<td>容器端口的主机端口映射. 演示一个单机容器.</td>
</tr>
<tr>
<td>image</td>
<td></td>
<td></td>
<td>容器运行的镜像.</td>
</tr>
<tr>
<td>image-pull-policy</td>
<td></td>
<td></td>
<td>容器的镜像拉取策略. 如果为空，则该值不会由客户端指定，并由服务器默认.</td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true]</td>
</tr>
<tr>
<td>labels</td>
<td>l</td>
<td></td>
<td>应用于 pod(s) 的标签 .</td>
</tr>
<tr>
<td>leave-stdin-open</td>
<td></td>
<td>false</td>
<td>如果 pod 以交互模式启动，或者使用 stdin 启动，则在第一次附加完成后将 stdin 打开. 默认情况下，stdin 将在第一个附加完成后关闭. </td>
</tr>
<tr>
<td>limits</td>
<td></td>
<td></td>
<td>此容器的资源需求限制. 例如，'cpu = 200m，memory = 512Mi'. 请注意，服务器端组件可能会根据服务器配置（如限制范围）分配限制. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>当使用默认或自定义列输出格式时，请勿打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>overrides</td>
<td></td>
<td></td>
<td>为生成的对象的内联 JSON 覆盖.如果这是非空的，它将被用来覆盖生成的对象.要求对象提供一个有效的 apiVersion 字段. </td>
</tr>
<tr>
<td>port</td>
<td></td>
<td></td>
<td>该容器暴露的端口. 如果 --expose 为 true，则这也是创建的服务使用的端口. </td>
</tr>
<tr>
<td>quiet</td>
<td></td>
<td>false</td>
<td>如果为 true，则禁止提示信息. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前 kubectl 命令.如果设置为 false，则不记录该命令.如果设置为 true，则记录该命令.如果没有设置，则默认仅更新已有的注释值. </td>
</tr>
<tr>
<td>replicas</td>
<td>r</td>
<td>1</td>/
<td>为这个容器创建的副本数量.默认是1. </td>
</tr>
<tr>
<td>requests</td>
<td></td>
<td></td>
<td>此容器的资源需求请求. 例如，'cpu = 100m，memory = 256Mi'. 请注意，服务器端组件可能会根据服务器配置分配请求，例如限制范围. </td>
</tr>
<tr>
<td>restart</td>
<td></td>
<td>Always</td>
<td>该Pod的重新启动策略. 合法值[ Always，OnFailure，Never ]. 如果设置为 “Always” ，则创建 deployment ，如果设置为 “OnFailure” ，则创建 job ，如果设置为 “Never” ，则会创建一个常规 pod. 对于后两个--replicas 必须为1.默认为 “Always”，对于 CronJobs <code>Never</code>. </td>
</tr>
<tr>
<td>rm</td>
<td></td>
<td>false</td>
<td>如果为 true，则删除在此命令中为附加的容器创建的资源. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果是 true ，那么当前对象的配置将在其注释中保存.当您希望在将来执行 kubectl 应用于此对象时，这是很有用的. </td>
</tr>
<tr>
<td>schedule</td>
<td></td>
<td></td>
<td>一个 Cron 格式的时间表应该与作业一起运行. </td>
</tr>
<tr>
<td>service-generator</td>
<td></td>
<td>service/v2</td>
<td>用于创建服务的生成器的名称. 仅当 --expose 为 true 时才使用. </td>
</tr>
<tr>
<td>service-overrides</td>
<td></td>
<td></td>
<td>为生成的服务对象的内联 JSON 覆盖. 如果这是非空的，它将用于覆盖生成的对象. 需要对象提供有效的 apiVersion 字段. 仅当 --expose 为 true 时才使用. </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod ）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如“{.metadata.name}”）.由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>stdin</td>
<td>i</td>
<td>false</td>
<td>即使没有附加任何东西，也要在pod的容器上打开 stdin </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>当 -o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>tty</td>
<td>t</td>
<td>false</td>
<td>为 pod 中的每个容器分配一个 TTY. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="expose">expose</h1>
<blockquote class="code-block example">
<p> 为复制的 nginx 创建一个服务，该服务在端口80上运行，并连接到端口8000上的容器.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-comment">rc</span> <span class="hljs-comment">nginx</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=80</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">target</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8000</span>
</code></pre>
<blockquote class="code-block example">
<p> 为由 “nginx-controller.yaml” 中指定的类型和名称标识的复制控制器创建服务，该命令在端口80上运行，并连接到端口8000上的容器.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-literal">-</span><span class="hljs-comment">f</span> <span class="hljs-comment">nginx</span><span class="hljs-literal">-</span><span class="hljs-comment">controller</span><span class="hljs-string">.</span><span class="hljs-comment">yaml</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=80</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">target</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8000</span>
</code></pre>
<blockquote class="code-block example">
<p> 为一个 pod 的有效端口创建一个服务，该服务在444的端口使用名为“frontend”</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-comment">pod</span> <span class="hljs-comment">valid</span><span class="hljs-literal">-</span><span class="hljs-comment">pod</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=444</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">name=frontend</span>
</code></pre>
<blockquote class="code-block example">
<p> 基于上述服务创建第二个服务，将容器端口8443对外暴露为端口443，名称为 “nginx-https”</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-comment">service</span> <span class="hljs-comment">nginx</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=443</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">target</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8443</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">name=nginx</span><span class="hljs-literal">-</span><span class="hljs-comment">https</span>
</code></pre>
<blockquote class="code-block example">
<p> 为端口4100上的复制流应用创建一个服务，平衡UDP流量并命名为“video-stream”.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-comment">rc</span> <span class="hljs-comment">streamer</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=4100</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">protocol=udp</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">name=video</span><span class="hljs-literal">-</span><span class="hljs-comment">stream</span>
</code></pre>
<blockquote class="code-block example">
<p> 为使用副本集的复制的 nginx 创建一个服务,该服务使用80端口，并连接到容器的8000端口上</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-comment">rs</span> <span class="hljs-comment">nginx</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=80</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">target</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8000</span>
</code></pre>
<blockquote class="code-block example">
<p> 为一个 nginx deployment 创建服务，该服务在端口80上运行，并连接到容器的8000端口.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">expose</span> <span class="hljs-comment">deployment</span> <span class="hljs-comment">nginx</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=80</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">target</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8000</span>
</code></pre>
<p>将资源作为新的Kubernetes服务. </p>
<p>根据名称查找部署，服务，副本集，复制控制器或 pod，并将该资源的选择器用作指定端口上的新服务的选择器. 只有当其选择器可转换为服务支持的选择器时，即当选择器仅包含 matchLabels 组件时，部署或副本集才会作为服务公开. 请注意，如果没有通过端口指定端口，并且暴露的资源具有多个端口，则新服务将重新使用所有端口. 另外如果没有指定标签，新的服务将重新使用它所暴露的资源的标签.</p>
<p>可能的资源包括（不区分大小写）： </p>
<p>pod (po), service (svc), replicationcontroller (rc), deployment (deploy), replicaset (rs)</p>
<h3 id="usage">用法</h3>
<p><code>$ expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster-ip</td>
<td></td>
<td></td>
<td>分配给服务的 ClusterIP. 留空以自动分配，或设置为 “None” 创建无头服务. </td>
</tr>
<tr>
<td>container-port</td>
<td></td>
<td></td>
<td>与 --target-port 作用相同</td>
</tr>
<tr>
<td>create-external-load-balancer</td>
<td></td>
<td>false</td>
<td>如果为 true，请为此服务创建一个外部负载均衡器（通过 --type 获取 ）. 实施是依赖于云提供商. 默认值为 “false”. </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>external-ip</td>
<td></td>
<td></td>
<td>额外的外部 IP 地址（不由 Kubernetes 管理）接受服务请求. 如果该 IP 路由到一个节点，除了生成的服务 IP 之外，还可以通过该 IP 访问该服务. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名、目录或 URL ，以识别用于公开服务的资源的文件 </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>service/v2</td>
<td>要使用的 API 生成器的名称. 有2个生成器：'service / v1' 和 'service / v2'. 它们之间的唯一区别是 v1 中的服务端口被命名为 “default”，而在 v2 中它没有被命名. 默认为 'service / v2'. </td>
</tr>
<tr>
<td>labels</td>
<td>l</td>
<td></td>
<td>应用于此呼叫创建的服务的标签. </td>
</tr>
<tr>
<td>load-balancer-ip</td>
<td></td>
<td></td>
<td>分配给负载均衡器的 IP.如果空，将创建和使用临时 IP (特定于云提供商). </td>
</tr>
<tr>
<td>name</td>
<td></td>
<td></td>
<td>新创建的对象的名称. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>overrides</td>
<td></td>
<td></td>
<td>为生成的对象的内联 JSON 覆盖.如果这是非空的，它将被用来覆盖生成的对象.要求对象提供一个有效的 apiVersion 字段. </td>
</tr>
<tr>
<td>port</td>
<td></td>
<td></td>
<td>服务应该服务于的端口.如果未指定，则从被公开的资源中复制. </td>
</tr>
<tr>
<td>protocol</td>
<td></td>
<td></td>
<td>要创建的服务的网络协议. 默认为 'TCP'. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前 kubectl 命令.如果设置为 false，则不记录该命令.如果设置为 true，则记录该命令.如果没有设置，则默认仅更新已有的注释值. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>selector</td>
<td></td>
<td></td>
<td>用于此服务的标签选择器. 只支持基于等式的选择器要求. 如果为空（默认值）从复制控制器或副本集推断出选择器. </td>
</tr>
<tr>
<td>session-affinity</td>
<td></td>
<td></td>
<td>如果非空，设置会话与此相关的服务; 合法值: ‘None’ , ‘ClientIP’ </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod ）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为JSONPath表达式（例如 “{.metadata.name}” ）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串.</td>
</tr>
<tr>
<td>target-port</td>
<td></td>
<td></td>
<td>容器端口的名称或号码，该服务应该引导流量. 可选的. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>type</td>
<td></td>
<td></td>
<td>键入此服务：ClusterIP，NodePort 或 LoadBalancer. 默认为 'ClusterIP'.</td>
</tr>
</tbody>
</table>

<h1 id="-strong-app-management-strong-"><strong>APP 管理</strong></h1>
<p>本节包含用于创建，更新，删除和
在 Kubernetes 群集中查看您的工作负载.</p>
<hr>
<h1 id="annotate">annotate</h1>
<blockquote class="code-block example">
<p> 使用注释 'description' 和值 'my frontend' 更新 pod'foo'. ＃如果相同的注释多次设置，则只会应用最后一个值</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl annotate pods foo description</span>=<span class="hljs-string">'my frontend'</span>
</code></pre>
<blockquote class="code-block example">
<p> 在 “pod.json” 中更新由类型和名称标识的 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl annotate -f pod<span class="hljs-selector-class">.json</span> description=<span class="hljs-string">'my frontend'</span>
</code></pre>
<blockquote class="code-block example">
<p> 使用注释 'description' 和值 'my frontend running nginx' 更新  pod'foo'，并覆盖任何现有值.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">annotate </span><span class="hljs-built_in">--overwrite</span> <span class="hljs-string">pods </span><span class="hljs-string">foo </span><span class="hljs-string">description=</span><span class="hljs-string">'my frontend running nginx'</span>
</code></pre>
<blockquote class="code-block example">
<p> 更新命名空间中的所有 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">annotate </span><span class="hljs-string">pods </span><span class="hljs-built_in">--all</span> <span class="hljs-string">description=</span><span class="hljs-string">'my frontend running nginx'</span>
</code></pre>
<blockquote class="code-block example">
<p> 仅当资源与版本1没有变化时才更新 pod'foo'.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl annotate pods foo description='<span class="hljs-keyword">my</span> frontend <span class="hljs-built_in">running</span> nginx' <span class="hljs-comment">--resource-version=1</span>
</code></pre>
<blockquote class="code-block example">
<p> 通过删除名为 “description” 的注释（如果存在）更新 pod'foo'. ＃不需要 --overwrite 标志.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl annotate pods foo <span class="hljs-keyword">description</span>-
</code></pre>
<p>更新一个或多个资源上的注释. </p>
<ul>
<li>注释是一个可以容纳更大的键/值对(与标签相比)，而且可能不是人类可读的数据.  </li>
<li>它的目的是存储非识别辅助数据，特别是通过工具和系统扩展操作的数据. </li>
<li>如果 --overwrite 为真，则可以覆盖现有注释，否则尝试覆盖注释将导致错误.  </li>
<li>如果指定了 --resource-version，则更新将使用此资源版本，否则将使用现有的资源版本.  </li>
</ul>
<p>有效的资源类型包括：</p>
<ul>
<li>clusters (仅适用于联邦 apiservers)  </li>
<li>componentstatuses (又称 &#39;cs&#39;)  </li>
<li>configmaps (又称 &#39;cm&#39;)  </li>
<li>daemonsets (又称 &#39;ds&#39;)  </li>
<li>deployments (又称 &#39;deploy&#39;)  </li>
<li>endpoints (又称 &#39;ep&#39;)  </li>
<li>events (又称 &#39;ev&#39;)  </li>
<li>horizontalpodautoscalers (又称 &#39;hpa&#39;)  </li>
<li>ingresses (又称 &#39;ing&#39;)  </li>
<li>jobs  </li>
<li>limitranges (又称 &#39;limits&#39;)  </li>
<li>namespaces (又称 &#39;ns&#39;)  </li>
<li>networkpolicies  </li>
<li>nodes (又称 &#39;no&#39;)  </li>
<li>persistentvolumeclaims (又称 &#39;pvc&#39;)  </li>
<li>persistentvolumes (又称 &#39;pv&#39;)  </li>
<li>pods (又称 &#39;po&#39;)  </li>
<li>podsecuritypolicies (又称 &#39;psp&#39;)  </li>
<li>podtemplates  </li>
<li>replicasets (又称 &#39;rs&#39;)  </li>
<li>replicationcontrollers (又称 &#39;rc&#39;)  </li>
<li>resourcequotas (又称 &#39;quota&#39;)  </li>
<li>secrets  </li>
<li>serviceaccounts (又称 &#39;sa&#39;)  </li>
<li>services (又称 &#39;svc&#39;)  </li>
<li>statefulsets  </li>
<li>storageclasses  </li>
<li>thirdpartyresources</li>
</ul>
<h3 id="usage">用法</h3>
<p><code>$ annotate [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>选择指定资源类型的命名空间中的所有资源. </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名、目录或 URL，以识别用于更新注释的资源的文件. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>local</td>
<td></td>
<td>false</td>
<td>如果为 true，则注释不会与 api-server 联系，而是在本地运行. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1” ）. </td>
</tr>
<tr>
<td>overwrite</td>
<td></td>
<td>false</td>
<td>如果为 true，则允许注释被覆盖，否则会拒绝覆盖现有注释的注释更新. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false ，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>resource-version</td>
<td></td>
<td></td>
<td>如果非空，则注释更新只有在对象的当前资源版本时才会成功. 仅在指定单个资源时有效. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td> 使用选择器（标签查询）进行过滤 </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如“{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="autoscale">autoscale</h1>
<blockquote class="code-block example">
<p> 自动缩放一个 deployment 资源 “foo”，其中 pod 的数量在2到10之间，指定了目标 CPU 利用率，因此将使用默认自动缩放策略：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl autoscale deployment foo --<span class="hljs-built_in">min</span>=<span class="hljs-number">2</span> --<span class="hljs-built_in">max</span>=<span class="hljs-number">10</span>
</code></pre>
<blockquote class="code-block example">
<p> 自动缩放一个 Replication Controller 资源 “foo”，其中 pod 的数量在1到5之间，目标 CPU 利用率为80％：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">autoscale</span> <span class="hljs-comment">rc</span> <span class="hljs-comment">foo</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">max=5</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">cpu</span><span class="hljs-literal">-</span><span class="hljs-comment">percent=80</span>
</code></pre>
<p>创建一个自动缩放器，可自动选择并设置在 kubernetes 群集中运行的 pod 数量. </p>
<p>通过名称查找 Deployment，ReplicaSet 或 ReplicationController，并创建一个使用给定资源作为参考的自动缩放器. 一个自动缩放器可以根据需要自动增加或减少系统中部署的 pod 数量.</p>
<h3 id="usage">用法</h3>
<p><code>$ autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>cpu-percent</td>
<td></td>
<td>-1</td>
<td>所有 pod 上的目标平均 CPU 利用率（以请求的 CPU 的百分比表示）. 如果未指定或否定，则将使用默认自动缩放策略. </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL 到标识要自动调整的资源的文件. </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>horizontalpodautoscaler/v1</td>
<td>要使用的 API 生成器的名称. 目前只有 v1 生成器. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>max</td>
<td></td>
<td>-1</td>
<td>可由 autoscaler 设置的 pod 的上限.需要的. </td>
</tr>
<tr>
<td>min</td>
<td></td>
<td>-1</td>
<td>可由自动缩放器设置的 pod 数量的下限. 如果未指定或否定，则服务器将应用默认值. </td>
</tr>
<tr>
<td>name</td>
<td></td>
<td></td>
<td>新创建的对象的名称. 如果未指定，将使用输入资源的名称.</td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题.</td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] and jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1” ）. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="convert">convert</h1>
<blockquote class="code-block example">
<p> 将 “pod.yaml” 转换为最新版本并打印到 stdout.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl convert <span class="hljs-_">-f</span> pod.yaml
</code></pre>
<blockquote class="code-block example">
<p> 将由 “pod.yaml” 指定的资源的实时状态转换为最新版本，并以 json 格式打印到 stdout.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">convert</span> -f pod.yaml <span class="hljs-comment">--local -o json</span>
</code></pre>
<blockquote class="code-block example">
<p> 将当前目录下的所有文件转换为最新版本，并将其全部创建.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl convert <span class="hljs-_">-f</span> . | kubectl create <span class="hljs-_">-f</span> -
</code></pre>
<p>在不同 API 版本之间转换配置文件. 允许使用 YAML 和 JSON 格式 .</p>
<p>该命令将文件名，目录或 URL 作为输入，并将其转换为由 --output-version 标志指定的版本格式. 如果目标版本未指定或不支持，请转换为最新版本. </p>
<p>默认输出将以 YAML 格式打印到 stdout. 可以使用 -o 选项更改为输出目的地.</p>
<h3 id="usage">用法</h3>
<p><code>$ convert -f FILENAME</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>要获得转换的文件的文件名，目录或 URL. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>local</td>
<td></td>
<td>true</td>
<td>如果为 true，则转换不会尝试联系 api 服务器，而是在本地运行. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题.打印头. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>
217/5000
输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath =  ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如： “extensions / v1beta1” ）. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="create">create</h1>
<blockquote class="code-block example">
<p> 使用 pod.json 中的数据创建一个 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create <span class="hljs-_">-f</span> ./pod.json
</code></pre>
<blockquote class="code-block example">
<p> 根据传入 stdin 的 JSON 创建一个 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">cat pod.json <span class="hljs-string">| kubectl create -f -</span>
</code></pre>
<blockquote class="code-block example">
<p> 使用 v1 API 格式在 JSON 中的 docker-registry.yaml 中编辑数据，然后使用编辑的数据创建资源.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">create</span> -f docker-registry.yaml --<span class="hljs-keyword">edit</span> --<span class="hljs-keyword">output</span>-version=v1 -o json
</code></pre>
<p>通过文件名或 stdin 创建一个资源. </p>
<p>可以使用 JSON 和 YAML 格式</p>
<h3 id="usage">用法</h3>
<p><code>$ create -f FILENAME</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>edit</td>
<td></td>
<td>false</td>
<td>在创建之前编辑 API 资源 </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>用于创建资源的文件的文件名，目录或URL </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题.</td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ... 查看自定义列[<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”). </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前 kubectl 命令.如果设置为 false，则不记录该命令.如果设置为 true，则记录该命令.如果没有设置，则默认仅更新已有的注释值. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
<tr>
<td>windows-line-endings</td>
<td></td>
<td>false</td>
<td>只有相关的 --edit = true. 使用 Windows 行结尾（默认Unix行结尾）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-configmap-em-"><em>configmap</em></h2>
<blockquote class="code-block example">
<p> 使用文件夹栏中每个文件的键创建一个名为 my-config 的新 configmap
</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create configmap my-config --<span class="hljs-keyword">from</span>-<span class="hljs-keyword">file</span>=path<span class="hljs-regexp">/to/</span>bar
</code></pre>
<blockquote class="code-block example">
<p> 创建一个名为 my-config 的新的 configmap，使用指定的键而不是磁盘上的名称</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create configmap my-config --<span class="hljs-keyword">from</span>-<span class="hljs-keyword">file</span>=key1=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/bar/</span>file1.txt --<span class="hljs-keyword">from</span>-<span class="hljs-keyword">file</span>=key2=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/bar/</span>file2.txt
</code></pre>
<blockquote class="code-block example">
<p> 使用 key1 = config1 和 key2 = config2 创建一个名为 my-config 的新配置图</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create configmap my-<span class="hljs-built_in">config</span> --from-literal=key1=<span class="hljs-built_in">config1</span> --from-literal=key2=<span class="hljs-built_in">config2</span>
</code></pre>
<p>根据文件，目录或指定的文字值创建一个 configmap .</p>
<p>单个 configmap 可以打包一个或多个键/值对. </p>
<p>当基于文件创建配置映射时，密钥将默认为文件的基本名称，该值将默认为文件内容. 如果基本名称是无效键，则可以指定备用键 .</p>
<p>当基于目录创建配置映射时，其名称是目录中的有效键的每个文件将被打包到 configmap 中. 除了常规文件之外的任何目录条目都被忽略（例如子目录，符号链接，设备，管道等）.</p>
<h3 id="usage">用法</h3>
<p><code>$ configmap NAME [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送 .</td>
</tr>
<tr>
<td>from-file</td>
<td></td>
<td>[]</td>
<td>可以使用其文件路径指定密钥文件，在这种情况下，将为其提供默认名称，或者可选地使用名称和文件路径，在这种情况下将使用给定的名称. 指定一个目录将遍历目录中的每个命名文件，该目录是一个有效的配置映射密钥 . </td>
</tr>
<tr>
<td>from-literal</td>
<td></td>
<td>[]</td>
<td>指定要在 configmap 中插入的键和字面值（即 mykey = somevalue ） </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>configmap/v1</td>
<td>要使用的 API 生成器的名称 . </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题 . </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ... 查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）.</td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-deployment-em-"><em>deployment</em></h2>
<blockquote class="code-block example">
<p> 创建运行 busybox 映像的名为 my-dep 的新部署.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create deployment <span class="hljs-keyword">my</span>-dep <span class="hljs-comment">--image=busybox</span>
</code></pre>
<p>创建具有指定名称的部署.</p>
<h3 id="usage">Usage</h3>
<p><code>$ deployment NAME --image=image [--dry-run]</code></p>
<h3 id="flags">Flags</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Shorthand</th>
<th>Default</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送 . </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>deployment-basic/v1beta1</td>
<td>要使用的 API 生成器的名称 . </td>
</tr>
<tr>
<td>image</td>
<td></td>
<td>[]</td>
<td>要运行的图像名称. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”） </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用 . </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' .</td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）.</td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）.</td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}” ）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串.</td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入.</td>
</tr> 
</tbody>
</table>
<hr>
<h2 id="-em-namespace-em-"><em>namespace</em></h2>
<blockquote class="code-block example">
<p> 创建一个名为 my-namespace 的新命名空间</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">create</span> <span class="hljs-keyword">namespace</span> my-<span class="hljs-keyword">namespace</span>
</code></pre>
<p>创建一个具有指定名称的命名空间.</p>
<h3 id="usage">用法</h3>
<p><code>$ namespace NAME [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送.</td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>namespace/v1</td>
<td>要使用的 API 生成器的名称.</td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）.</td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-quota-em-"><em>quota</em></h2>
<blockquote class="code-block example">
<p>创建一个名为 my-quota 的新资源</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">$ kubectl create quota my-quota --hard=cpu=<span class="hljs-number">1</span>,memory=<span class="hljs-number">1</span>G,pods=<span class="hljs-number">2</span>,services=<span class="hljs-number">3</span>,replicationcontrollers=<span class="hljs-number">2</span>,resourcequotas=<span class="hljs-number">1</span>,secrets=<span class="hljs-number">5</span>,persistentvolumeclaims=<span class="hljs-number">10</span>
</code></pre>
<blockquote class="code-block example">
<p>创建一个名为 best-effort 的新资源</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">$ kubectl <span class="hljs-keyword">create</span> <span class="hljs-keyword">quota</span> best-effort <span class="hljs-comment">--hard=pods=100 --scopes=BestEffort</span>
</code></pre>
<p>创建具有指定名称，硬限制和可选作用域的资源量</p>
<h3 id="usage">用法</h3>
<p><code>$ quota NAME [--hard=key1=value1,key2=value2] [--scopes=Scope1,Scope2] [--dry-run=bool]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送.</td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>resourcequotas/v1</td>
<td>要使用的 API 生成器的名称. </td>
</tr>
<tr>
<td>hard</td>
<td></td>
<td></td>
<td>用逗号分隔的一组资源=数量对来定义硬限制. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）.</td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用.</td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>scopes</td>
<td></td>
<td></td>
<td>以逗号分隔的一组配额范围，必须全部匹配配额追踪的每个对象 .</td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-secret-em-"><em>secret</em></h2>
<p>使用指定的子命令创建一个秘密.</p>
<h3 id="usage">用法</h3>
<p><code>$ secret</code></p>
<hr>
<h2 id="-em-secret-docker-registry-em-"><em>secret docker-registry</em></h2>
<blockquote class="code-block example">
<p> 如果您还没有 .dockercfg 文件，则可以直接使用以下命令创建 dockercfg 密码：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">create</span> <span class="hljs-comment">secret</span> <span class="hljs-comment">docker</span><span class="hljs-literal">-</span><span class="hljs-comment">registry</span> <span class="hljs-comment">my</span><span class="hljs-literal">-</span><span class="hljs-comment">secret</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">docker</span><span class="hljs-literal">-</span><span class="hljs-comment">server=DOCKER_REGISTRY_SERVER</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">docker</span><span class="hljs-literal">-</span><span class="hljs-comment">username=DOCKER_USER</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">docker</span><span class="hljs-literal">-</span><span class="hljs-comment">password=DOCKER_PASSWORD</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">docker</span><span class="hljs-literal">-</span><span class="hljs-comment">email=DOCKER_EMAIL</span>
</code></pre>
<p>创建一个与 Docker 注册中心一起使用的新密钥. </p>
<p>Dockercfg 密钥用于对 Docker 注册表进行身份验证. </p>
<p>使用 Docker 命令行推送 images 时，可以通过运行对给定的注册表进行身份验证 </p>
<p>  $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --password=DOCKER_PASSWORD --email=DOCKER_EMAIL&#39;.</p>
<p>这会产生一个 ~/.dockercfg 文件，用于后来的 'docker push' 和 'docker pull' 命令对注册表进行身份验证. </p>
<p>创建应用程序时，您可能需要一个需要验证的 Docker 注册表. 为了让 node 代表你的拉取 images，他们必须拥有凭据. 您可以通过创建 dockercfg 密钥并将其附加到您的服务帐户来提供此信息.</p>
<h3 id="usage">用法</h3>
<p><code>$ docker-registry NAME --docker-username=user --docker-password=password --docker-email=email [--docker-server=string] [--from-literal=key1=value1] [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>标示</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker-email</td>
<td></td>
<td></td>
<td>Docker 注册中心的电子邮件 </td>
</tr>
<tr>
<td>docker-password</td>
<td></td>
<td></td>
<td>Docker注册中心验证密码 </td>
</tr>
<tr>
<td>docker-server</td>
<td></td>
<td><a href="https://index.docker.io/v1/">https://index.docker.io/v1/</a></td>
<td>Docker 注册中心的服务器位置 </td>
</tr>
<tr>
<td>docker-username</td>
<td></td>
<td></td>
<td>Docker 注册认证的用户名 </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>secret-for-docker-registry/v1</td>
<td>要使用的 API 生成器的名称 . </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-secret-generic-em-"><em>secret generic</em></h2>
<blockquote class="code-block example">
<p> 在文件夹栏中为每个文件创建一个名为 my - secret 的新密钥</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create secret <span class="hljs-keyword">generic</span> my-secret --from-<span class="hljs-keyword">file</span>=path/<span class="hljs-keyword">to</span>/bar
</code></pre>
<blockquote class="code-block example">
<p> 使用指定的密钥创建一个名为 my-secret 的新密钥，而不是磁盘上的名称</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create secret generic my-secret --<span class="hljs-keyword">from</span>-<span class="hljs-keyword">file</span>=ssh-privatekey=~<span class="hljs-regexp">/.ssh/i</span>d_rsa --<span class="hljs-keyword">from</span>-<span class="hljs-keyword">file</span>=ssh-publickey=~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub
</code></pre>
<blockquote class="code-block example">
<p> 用 key1 = supersecret 和 key2 = topsecret 创建一个名为 my-secret 的新密钥</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create secret <span class="hljs-keyword">generic</span> my-secret --<span class="hljs-keyword">from</span>-literal=key1=supersecret --<span class="hljs-keyword">from</span>-literal=key2=topsecret
</code></pre>
<p>根据文件，目录或指定的文字值创建一个秘密. </p>
<p>单个密钥可以包装一个或多个键/值对. </p>
<p>当基于文件创建秘密时，密钥将默认为文件的基本名称，该值将默认为文件内容. 如果基本名称是无效键，则可以指定备用键. </p>
<p>当基于目录创建秘密时，其名称是该目录中的有效密钥的每个文件将被打包到该秘密中. 除了常规文件之外的任何目录项被忽略（例如子目录，符号链接，设备，管道等）.</p>
<h3 id="usage">用法</h3>
<p><code>$ generic NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>标示</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>from-file</td>
<td></td>
<td>[]</td>
<td>可以使用其文件路径指定密钥文件，在这种情况下，将为其提供默认名称，或者可选地使用名称和文件路径，在这种情况下将使用给定的名称. 指定一个目录将遍历作为有效密钥的目录中的每个命名文件. </td>
</tr>
<tr>
<td>from-literal</td>
<td></td>
<td>[]</td>
<td>指定键和值插入密钥（即 mykey = somevalue）</td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>secret/v1</td>
<td>要使用的 API 生成器的名称. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ... 查看自定义列[<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用.
 </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如“ {.metadata.name}”）. 由此 JSONPath表达式指定的API资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>type</td>
<td></td>
<td></td>
<td>创建的密钥类型 </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-secret-tls-em-"><em>secret tls</em></h2>
<blockquote class="code-block example">
<p> 使用给定的密钥对创建名为 tls-secret 的新 TLS 密钥：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create secret tls tls-secret --cert=path/<span class="hljs-keyword">to</span>/tls.cert --<span class="hljs-keyword">key</span>=path/<span class="hljs-keyword">to</span>/tls.<span class="hljs-keyword">key</span>
</code></pre>
<p>从给定的公钥/私钥对创建 TLS 密钥.</p>
<p>公钥/私钥对必须存在. 公共密钥证书必须是.PEM 编码，并与给定的私钥相匹配.</p>
<h3 id="usage">用法</h3>
<p><code>$ tls NAME --cert=path/to/cert/file --key=path/to/key/file [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>cert</td>
<td></td>
<td></td>
<td>PEM 编码公钥证书的路径 . </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>secret-for-tls/v1</td>
<td>要使用的 API 生成器的名称. </td>
</tr>
<tr>
<td>key</td>
<td></td>
<td></td>
<td>与给定证书关联的私钥的路径. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ... 查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如： “extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用.
 </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-service-em-"><em>service</em></h2>
<p>使用指定的子命令创建一个服务.</p>
<h3 id="usage">用法</h3>
<p><code>$ service</code></p>
<hr>
<h2 id="-em-service-clusterip-em-"><em>service clusterip</em></h2>
<blockquote class="code-block example">
<p> 创建一个名为 my-cs 的新的 clusterIP 服务</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create service clusterip <span class="hljs-keyword">my</span>-cs <span class="hljs-comment">--tcp=5678:8080</span>
</code></pre>
<blockquote class="code-block example">
<p> 创建一个名为 my-cs 的新的 clusterIP 服务（在 headless 模式下）</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create service clusterip <span class="hljs-keyword">my</span>-cs <span class="hljs-comment">--clusterip="None"</span>
</code></pre>
<p>创建具有指定名称的 clusterIP 服务.</p>
<h3 id="usage">用法</h3>
<p><code>$ clusterip NAME [--tcp=&lt;port&gt;:&lt;targetPort&gt;] [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>clusterip</td>
<td></td>
<td></td>
<td>分配您自己的 ClusterIP 或 设置为 “none” 为 “headless service” 服务（无负载平衡）. </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>service-clusterip/v1</td>
<td>要使用的 API 生成器的名称. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ... 查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）.</td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串.</td>
</tr>
<tr>
<td>tcp</td>
<td></td>
<td>[]</td>
<td>端口对可以指定为 '<port>：<targetPort>'. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-service-loadbalancer-em-"><em>service loadbalancer</em></h2>
<blockquote class="code-block example">
<p> 创建一个名为 my-lbs 的新的 LoadBalancer 服务</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create service loadbalancer <span class="hljs-keyword">my</span>-lbs <span class="hljs-comment">--tcp=5678:8080</span>
</code></pre>
<p>创建一个指定名称的 LoadBalancer 服务.</p>
<h3 id="usage">用法</h3>
<p><code>$ loadbalancer NAME [--tcp=port:targetPort] [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送 . </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>service-loadbalancer/v1</td>
<td>要使用的 API 生成器的名称.</td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）.</td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串.</td>
</tr>
<tr>
<td>tcp</td>
<td></td>
<td>[]</td>
<td>端口对可以指定为 '<port>：<targetPort>'. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 .</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-service-nodeport-em-"><em>service nodeport</em></h2>
<blockquote class="code-block example">
<p> 创建一个名为 my-ns 的新的 nodeport 服务</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl create service nodeport <span class="hljs-keyword">my</span>-ns <span class="hljs-comment">--tcp=5678:8080</span>
</code></pre>
<p>	创建具有指定名称的 nodeport 服务.</p>
<h3 id="usage">用法</h3>
<p><code>$ nodeport NAME [--tcp=port:targetPort] [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>service-nodeport/v1</td>
<td>要使用的 API 生成器的名称. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>node-port</td>
<td></td>
<td>0</td>
<td>用于在集群中的每个节点上公开服务的端口. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>tcp</td>
<td></td>
<td>[]</td>
<td>端口对可以指定为 '<port>：<targetPort>'. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-serviceaccount-em-"><em>serviceaccount</em></h2>
<blockquote class="code-block example">
<p> 创建一个名为 my-service-account 的新服务帐户</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">$ kubectl <span class="hljs-keyword">create</span> serviceaccount my-service-<span class="hljs-keyword">account</span>
</code></pre>
<p>创建具有指定名称的服务帐户.</p>
<h3 id="usage">用法</h3>
<p><code>$ serviceaccount NAME [--dry-run]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>generator</td>
<td></td>
<td>serviceaccount/v1</td>
<td>要使用的 API 生成器的名称. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr> 
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="delete">delete</h1>
<blockquote class="code-block example">
<p> 使用 pod.json 中指定的类型和名称删除 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">delete</span> -f ./pod.json
</code></pre>
<blockquote class="code-block example">
<p> 根据传入 stdin 的 JSON 类型和名称删除一个 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-keyword">cat</span> pod.json | kubectl <span class="hljs-keyword">delete</span> -<span class="hljs-keyword">f</span> -
</code></pre>
<blockquote class="code-block example">
<p> 删除具有相同名称 “baz” 和 “foo” 的 pod 和 services </p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">delete</span> pod,service baz foo
</code></pre>
<blockquote class="code-block example">
<p>删除标签名称为 myLabel 的 pod 和 services.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">delete</span> pods,services -l <span class="hljs-keyword">name</span>=myLabel
</code></pre>
<blockquote class="code-block example">
<p>以最小的延迟删除一个 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">delete</span> pod foo <span class="hljs-comment">--now</span>
</code></pre>
<blockquote class="code-block example">
<p> 强制删除死点上的 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">delete</span> <span class="hljs-comment">pod</span> <span class="hljs-comment">foo</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">grace</span><span class="hljs-literal">-</span><span class="hljs-comment">period=0</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">force</span>
</code></pre>
<blockquote class="code-block example">
<p> 删除 UID 为 1234-56-7890-234234-456456 的 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl delete pod <span class="hljs-number">1234</span><span class="hljs-number">-56</span><span class="hljs-number">-7890</span><span class="hljs-number">-234234</span><span class="hljs-number">-456456</span>
</code></pre>
<blockquote class="code-block example">
<p>删除所有 pod </p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">delete</span> pods <span class="hljs-comment">--all</span>
</code></pre>
<p>通过文件名，stdin，资源和名称，或资源和标签选择器删除资源. </p>
<p>可接收 JSON 和 YAML 格式. 可以只指定一种类型的参数：文件名，资源和名称，或资源和标签选择器. </p>
<p>一些资源，如 pod，支持优雅的删除. 这些资源在强制终止（宽限期）之前定义一个默认期限，但您可以使用 --grace-period 标志覆盖该值，或者将 pass -now 设置为宽限期为1，因为这些资源通常代表 集群中的实体，删除可能不会立即确认. 如果托管 pod 的节点已停机或无法到达 API 服务器，终止可能会比宽限期长得多. 要强制删除资源，您必须传递宽限期0，并指定 --force 标志.</p>
<p>重要提示：强制删除 pod 不等待确认 pod 的进程已被终止，这可以使这些进程运行，直到节点检测到删除并完成优雅删除. 如果您的进程使用共享存储或与远程 API 通信，并且依赖于 pod 的名称来标识自身，强制删除这些 pod 可能导致多个进程在不同的机器上运行，使用相同的标识，这可能导致数据损坏或不一致. 当您确定该端口被终止时，或者您的应用程序可以容忍一次运行的同一个 pod 的多个副本时，强制删除 pod. 此外，如果强制删除 pod，则调度程序可能会在节点释放这些资源之前将新的 pod 放在这些节点上，并使这些 pod 立即被逐出. </p>
<p>请注意，delete 命令不执行资源版本检查，因此，如果在提交删除时有人向资源提交更新，则其更新将与资源的其余部分一起丢失.</p>
<h3 id="usage">用法</h3>
<p><code>$ delete ([-f FILENAME] | TYPE [(NAME | -l label | --all)])</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>[-all] 选择所有指定的资源. </td>
</tr>
<tr>
<td>cascade</td>
<td></td>
<td>true</td>
<td>如果为 true，则级联对由此资源管理的资源的删除（例如由 ReplicationController 创建的 Pods）. 默认值为 true. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL 到包含要删除资源的文件. </td>
</tr>
<tr>
<td>force</td>
<td></td>
<td>false</td>
<td>立即删除某些资源可能导致不一致或数据丢失，需要确认. </td>
</tr>
<tr>
<td>grace-period</td>
<td></td>
<td>-1</td>
<td>给予资源的时间以秒为单位的时间. 如果为负，则忽略. </td>
</tr>
<tr>
<td>ignore-not-found</td>
<td></td>
<td>false</td>
<td>处理“资源未找到” 作为成功删除. 默认为 “true” 当 --all 被指定. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>now</td>
<td></td>
<td>false</td>
<td>如果为 true，资源将被指示立即关闭（与 --grace-period = 1相同）. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出模式. 使用 “-o name” 用于较短的输出（资源/名称）. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤.</td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>0s</td>
<td>在放弃删除之前等待的时间长度，零表示从对象的大小确定超时 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="edit">edit</h1>
<blockquote class="code-block example">
<p> 编辑名为 'docker-registry' 的服务：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">edit</span> svc/docker-registry
</code></pre>
<blockquote class="code-block example">
<p> 使用替代编辑器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attr">KUBE_EDITOR</span>=<span class="hljs-string">"nano"</span> kubectl edit svc/docker-registry
</code></pre>
<blockquote class="code-block example">
<p> 使用 v1 API 格式在 JSON 中编辑服务 'docker-registry'：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">edit</span> svc/docker-registry --<span class="hljs-keyword">output</span>-version=v1 -o json
</code></pre>
<p>从默认编辑器编辑资源.</p>
<p>编辑命令允许您直接编辑可以通过命令行工具检索的任何 API 资源. 它将打开您的 KUBE _EDITOR 或 EDITOR 环境变量定义的编辑器，或者对于 Linux 或 Windows的记事本可以回到 vi. 您可以编辑多个对象，但一次应用更改. 该命令接受文件名以及命令行参数，尽管您指向的文件必须是先前保存的资源版本.</p>
<p>要编辑的文件将以默认 API 版本或由 --output-version 指定的版本输出. 默认格式为 YAML - 如果您想在 JSON pass -o json 中编辑. 标志 --windows-line-endings 可用于强制 Windows 行结束，否则将使用您的操作系统的默认值. </p>
<p>在更新时发生错误的情况下，将在包含未应用更改的磁盘上创建一个临时文件. 更新资源时最常见的错误是另一个编辑器更改服务器上的资源. 发生这种情况时，您将必须将更改应用于资源的较新版本，或更新临时保存的副本以包含最新的资源版本.</p>
<h3 id="usage">用法</h3>
<p><code>$ edit (RESOURCE/NAME | -f FILENAME)</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或要用于编辑资源的文件的 URL </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td>yaml</td>
<td>输出格式. 其中之一： yaml | json. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr> 
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema'</td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
<tr>
<td>windows-line-endings</td>
<td></td>
<td>false</td>
<td>使用 Windows 行结尾（默认 Unix 行结尾） </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="get">get</h1>
<blockquote class="code-block example">
<p> 以 ps 输出格式列出所有 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">get</span> pods
</code></pre>
<blockquote class="code-block example">
<p> 列出具有更多信息（如节点名称）的 ps 输出格式的所有 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">get</span> pods -o wide
</code></pre>
<blockquote class="code-block example">
<p> 以 ps 输出格式列出具有指定 NAME 的单个复制控制器.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">get</span> replicationcontroller web
</code></pre>
<blockquote class="code-block example">
<p> 以 JSON 输出格式列出单个 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">get</span> -o json pod web-pod<span class="hljs-number">-13</span>je7
</code></pre>
<blockquote class="code-block example">
<p> 列出由 “pod.yaml” 中指定的类型和名称标识的 pod. 以 JSON 输出格式.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl get -f pod<span class="hljs-selector-class">.yaml</span> -o json
</code></pre>
<blockquote class="code-block example">
<p> 只返回指定的 POD 的相位值.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">get</span> -o <span class="hljs-keyword">template</span> pod/web-pod<span class="hljs-number">-13</span>je7 --<span class="hljs-keyword">template</span>={{.status.phase}}
</code></pre>
<blockquote class="code-block example">
<p> 以 ps 输出格式列出所有复制控制器和服务.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">get</span> rc,services
</code></pre>
<blockquote class="code-block example">
<p> 按照其类型和名称列出一个或多个资源.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">get</span> rc/web service/frontend pods/web-pod<span class="hljs-number">-13</span>je7
</code></pre>
<p>显示一个或多个资源. </p>
<p>有效的资源类型包括： </p>
<ul>
<li>clusters (仅适用于联邦 apiservers)  </li>
<li>componentstatuses (又名 'cs')  </li>
<li>configmaps (又名 'cm')  </li>
<li>daemonsets (又名 'ds')  </li>
<li>deployments (又名 'deploy')  </li>
<li>endpoints (又名 'ep')  </li>
<li>events (又名 ‘ev’)  </li>
<li>horizontalpodautoscalers (又名 ‘hpa’)  </li>
<li>ingresses (又名 'ing')  </li>
<li>jobs  </li>
<li>limitranges (又名 ‘limits’)  </li>
<li>namespaces (又名 ‘ns’)  </li>
<li>networkpolicies  </li>
<li>nodes (又名 ‘no’)  </li>
<li>persistentvolumeclaims (又名 ‘pvc’)  </li>
<li>persistentvolumes (又名 ‘pv’)  </li>
<li>pods (又名‘po')  </li>
<li>podsecuritypolicies 又名 ‘psp’)  </li>
<li>podtemplates  </li>
<li>replicasets (又名 ‘rs’)  </li>
<li>replicationcontrollers (又名 ‘rc’)  </li>
<li>resourcequotas (又名 ‘quota’)  </li>
<li>secrets  </li>
<li>serviceaccounts (又名 ‘sa’)  </li>
<li>services (又名 ‘svc’)  </li>
<li>statefulsets  </li>
<li>storageclasses  </li>
<li>thirdpartyresources  </li>
</ul>
<p>此命令将隐藏已完成的资源. 例如，处于成功或失败阶段的 pod. 您可以通过提供 “--show-all” 标志来查看任何资源的完整结果. </p>
<p>通过将输出指定为 “template”，并将 Go 模板提供为 --template 标志的值，您可以过滤获取的资源的属性.</p>
<h3 id="usage">用法</h3>
<p><code>$ get [(-o|--output=)json|yaml|wide|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...] (TYPE [NAME | -l label] | TYPE/NAME ...) [flags]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all-namespaces</td>
<td></td>
<td>false</td>
<td>如果存在，请在所有命名空间中列出所请求的对象. 当前上下文中的命名空间即使使用 --namespace 指定也将被忽略. </td>
</tr>
<tr>
<td>export</td>
<td></td>
<td>false</td>
<td>如果为 true，请使用 “export” 作为资源. 导出的资源被剥离了针对特定于群集的信息. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>label-columns</td>
<td>L</td>
<td>[]</td>
<td>接受以列表形式显示的标签的逗号分隔列表. 名称区分大小写. 您还可以使用多个标志选项，如 -L label1 -L label2 ... </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如： “extensions / v1beta1”）. </td>
</tr>
<tr>
<td>raw</td>
<td></td>
<td></td>
<td>要从服务器请求的原始 URI. 使用由 kubeconfig 文件指定的传输. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤 </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod.) </td>
</tr>
<tr>
<td>show-kind</td>
<td></td>
<td>false</td>
<td>如果存在，列出所请求对象的资源类型. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>watch</td>
<td>w</td>
<td>false</td>
<td>列出/获取所请求的对象后，请注意更改. </td>
</tr>
<tr>
<td>watch-only</td>
<td></td>
<td>false</td>
<td>观察所需对象的更改，而无需首先列出.</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="label">label</h1>
<blockquote class="code-block example">
<p> 更新名称为 'foo' 的 pod，标签为 “unhealthy”，值为 “true”.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">label</span><span class="bash"> pods foo unhealthy=<span class="hljs-literal">true</span></span>
</code></pre>
<blockquote class="code-block example">
<p>更新名称为'foo'的 pod 标签为 'status' 和值 'nothealthy'，覆盖任何现有的值.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">label</span><span class="bash"> --overwrite pods foo status=unhealthy</span>
</code></pre>
<blockquote class="code-block example">
<p> 更新命名空间中的所有 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">label</span><span class="bash"> pods --all status=unhealthy</span>
</code></pre>
<blockquote class="code-block example">
<p> 更新由 “pod.json” 中的类型和名称标识的 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-selector-tag">label</span> -f pod<span class="hljs-selector-class">.json</span> status=unhealthy
</code></pre>
<blockquote class="code-block example">
<p> 仅当资源与版本 1 不变时才更新 pod'foo'.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">label</span><span class="bash"> pods foo status=unhealthy --resource-version=1</span>
</code></pre>
<blockquote class="code-block example">
<p> 通过删除名为 “bar” 的标签（如果存在）更新 pod'foo'. ＃不需要 --overwrite 标志.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">label</span><span class="bash"> pods foo bar-</span>
</code></pre>
<p> 更新资源上的标签. </p>
<ul>
<li>标签必须以字母或数字开头，并且可以包含字母，数字，连字符，点和下划线，最多63个字符.  </li>
<li>如果 --overwrite 为 true，则可以覆盖现有标签，否则尝试覆盖标签将导致错误. </li>
<li>如果指定了 --resource-version，则更新将使用此资源版本，否则将使用现有的资源版本.</li>
</ul>
<h3 id="usage">用法</h3>
<p><code>$ label [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>选择指定资源类型的命名空间中的所有资源. </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL 到标识要更新标签的资源的文件 </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>local</td>
<td></td>
<td>false</td>
<td>如果为 true，则标签不会联系 api-server 而是在本地运行. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题.</td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>overwrite</td>
<td></td>
<td>false</td>
<td>如果为 true，则允许标签被覆盖，否则拒绝标记更新覆盖现有标签. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>resource-version</td>
<td></td>
<td></td>
<td>如果不为空，则标签更新将仅在该对象的当前资源版本成功. 仅在指定单个资源时有效.</td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤. </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="patch">patch</h1>
<blockquote class="code-block example">
<p>使用战略性合并补丁部分更新一个节点.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl patch <span class="hljs-keyword">node</span> <span class="hljs-title">k8s-node-1</span> -p '{<span class="hljs-string">"spec"</span>:{<span class="hljs-string">"unschedulable"</span>:<span class="hljs-literal">true</span>}}'
</code></pre>
<blockquote class="code-block example">
<p>部分更新由“node.json”中指定的类型和名称所标识的，使用战略合并补丁的节点</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl patch -f <span class="hljs-keyword">node</span>.<span class="hljs-title">json</span> -p '{<span class="hljs-string">"spec"</span>:{<span class="hljs-string">"unschedulable"</span>:<span class="hljs-literal">true</span>}}'
</code></pre>
<blockquote class="code-block example">
<p> 更新容器的image; spec.containers [*].name 是必需的，因为它是一个合并键</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl patch pod valid-pod -p <span class="hljs-string">'{"</span>spec<span class="hljs-string">":{"</span>containers<span class="hljs-string">":[{"</span>name<span class="hljs-string">":"</span>kubernetes-serve-hostname<span class="hljs-string">","</span>image<span class="hljs-string">":"</span>new image<span class="hljs-string">"}]}}'</span>
</code></pre>
<blockquote class="code-block example">
<p> 使用位置数组的 json 补丁更新容器的 image</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl patch pod valid-pod --<span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-symbol">'jso</span>n' -p='[{<span class="hljs-string">"op"</span>: <span class="hljs-string">"replace"</span>, <span class="hljs-string">"path"</span>: <span class="hljs-string">"/spec/containers/0/image"</span>, <span class="hljs-string">"value"</span>:<span class="hljs-string">"new image"</span>}]'
</code></pre>
<p>使用战略合并补丁更新资源的字段. </p>
<p>JSON 和 YAML 格式被接受. </p>
<p>请参考其中的型号 <a href="https://htmlpreview.github.io/?https://github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions.html">https://htmlpreview.github.io/?https://github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions.html</a> 去查找一个字段是否可变</p>
<h3 id="usage">用法</h3>
<p><code>$ patch (-f FILENAME | TYPE NAME) -p PATCH</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，以标识要更新的资源的文件. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义.[默认为 true] </td>
</tr>
<tr>
<td>local</td>
<td></td>
<td>false</td>
<td>如果为 true，则修补程序将对文件的内容进行操作，而不是服务器端资源.</td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）.</td>
</tr>
<tr>
<td>patch</td>
<td>p</td>
<td></td>
<td>要应用于资源 JSON 文件的补丁. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>type</td>
<td></td>
<td>strategic</td>
<td>提供的补丁类型; 一个 json 合并策略</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="replace">replace</h1>
<blockquote class="code-block example">
<p> 使用 pod.json 中的数据替换 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl replace <span class="hljs-_">-f</span> ./pod.json
</code></pre>
<blockquote class="code-block example">
<p> 根据传入 stdin 的 JSON 替换 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">cat pod.json | <span class="hljs-type">kubectl</span> <span class="hljs-built_in">replace</span> -f -
</code></pre>
<blockquote class="code-block example">
<p> 将单容器 pod 的 image 版本（tag）更新为 v4</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl get pod mypod -o yaml | <span class="hljs-type">sed</span> 's/\(image: myimage\):.*$/\<span class="hljs-number">1</span>:v4/' | <span class="hljs-type">kubectl</span> <span class="hljs-built_in">replace</span> -f -
</code></pre>
<blockquote class="code-block example">
<p> 强制替换,删除然后重新创建资源</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">replace</span> <span class="hljs-comment">--force -f ./pod.json</span>
</code></pre>
<p>用 filename 或 stdin 替换一个资源.</p>
<p>JSON 和 YAML 格式被接受. 如果替换现有资源，则必须提供完整的资源规范. 这可以通过获得 </p>
<p> $ kubectl get TYPE NAME -o yaml</p>
<p>请参考其中的型号 <a href="https://htmlpreview.github.io/?https://github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions.html">https://htmlpreview.github.io/?https://github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions.html</a> 查找一个字段是否可变.</p>
<h3 id="usage">用法</h3>
<p><code>$ replace -f FILENAME</code></p>
<h3 id="flags">标记</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>标示</th>
</tr>
</thead>
<tbody>
<tr>
<td>cascade</td>
<td></td>
<td>false</td>
<td>只在强制更换期间可用. 如果为 true，则级联删除由此资源管理的资源（例如由 ReplicationController 创建的 Pods）.</td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或要用于替换资源的文件的 URL. </td>
</tr>
<tr>
<td>force</td>
<td></td>
<td>false</td>
<td>删除并重新创建指定的资源. </td>
</tr>
<tr>
<td>grace-period</td>
<td></td>
<td>-1</td>
<td>只在强制更换期间可用. 在给旧资源的几秒钟内，可以优雅地终止.如果为负，则忽略. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出模式. 使用 “-o name” 用于较短的输出（资源/名称）. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>save-config</td>
<td></td>
<td>false</td>
<td>如果为 true，则当前对象的配置将保存在其注释中. 当您希望将来对此对象执行 kubectl 应用时，这很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema'</td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>0s</td>
<td>只在强制更换期间可用. 在放弃旧资源的删除之前等待的时间长度为零表示从对象的大小确定超时. 任何其他值应包含相应的时间单位（例如 1s，2m，3h）. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="rolling-update">rolling-update</h1>
<blockquote class="code-block example">
<p> 使用 frontend-v2.json 中的新复制控制器数据更新 frontend-v1 的 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-symbol">kubectl</span> rolling-update frontend-<span class="hljs-built_in">v1</span> -f frontend-<span class="hljs-built_in">v2</span>.json
</code></pre>
<blockquote class="code-block example">
<p> 使用传入 stdin 的 JSON 数据更新 frontend-v1 的 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-keyword">cat</span> frontend-v2.json | kubectl <span class="hljs-keyword">rolling</span>-<span class="hljs-keyword">update</span> frontend-v1 -f -
</code></pre>
<blockquote class="code-block example">
<p> 通过更改图像，并切换复制控制器的＃名称，将 frontend-v1 的 pod 更新为 frontend-v2.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-symbol">kubectl</span> rolling-update frontend-<span class="hljs-built_in">v1</span> frontend-<span class="hljs-built_in">v2</span> --image<span class="hljs-symbol">=image</span>:<span class="hljs-built_in">v2</span>
</code></pre>
<blockquote class="code-block example">
<p> 通过更改 image 来更新 frontend 的 pod，并保留旧名称.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rolling-update frontend --<span class="hljs-built_in">image</span>=<span class="hljs-built_in">image</span>:v2
</code></pre>
<blockquote class="code-block example">
<p> 终止和反转正在进行的现有进程（从 frontend-v1 到 frontend-v2）.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-symbol">kubectl</span> rolling-update frontend-<span class="hljs-built_in">v1</span> frontend-<span class="hljs-built_in">v2</span> --rollback
</code></pre>
<p>执行给定 ReplicationController 的滚动更新. </p>
<p>使用新的复本控制器替换指定的复本控制器，一次更新一个 pod 以使用新的 Pod 模板. new-controller.json 必须指定与现有复制控制器相同的命名空间，并覆盖其 replicaSelector 中至少一个（常用）标签. </p>
<p>! <a href="http://kubernetes.io/images/docs/kubectl_rollingupdate.svg">http://kubernetes.io/images/docs/kubectl_rollingupdate.svg</a></p>
<h3 id="usage">用法</h3>
<p><code>$ rolling-update OLD_CONTROLLER_NAME ([NEW_CONTROLLER_NAME] --image=NEW_CONTAINER_IMAGE | -f NEW_CONTROLLER_SPEC)</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>container</td>
<td></td>
<td></td>
<td>将升级其image的容器名称. 仅当 --image 被指定时才会相关，否则忽略. 在多容器 pod 使用 --image 时需要 </td>
</tr>
<tr>
<td>deployment-label-key</td>
<td></td>
<td>deployment</td>
<td>用于区分两个不同控制器的关键，默认为 “deployment”. 仅当 --image 被指定时才会相关，否则忽略 </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送.</td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>用于创建新复制控制器的文件名或 URL. </td>
</tr>
<tr>
<td>image</td>
<td></td>
<td></td>
<td>用于升级复制控制器的 image. 必须与现有 image（新 image 或新 image 标签）截然不同. 不能与 --filename / -f 一起使用 </td>
</tr>
<tr>
<td>image-pull-policy</td>
<td></td>
<td></td>
<td> 对何时拉容器图像的显式策略.必要时 --image 与现有 image 相同，否则会忽略.
 </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，通过对 API 服务器的调用包含新 API 的定义.(默认为 true) </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如： “extensions / v1beta1”）. </td>
</tr>
<tr>
<td>poll-interval</td>
<td></td>
<td>3s</td>
<td>轮询更新后的复制控制器状态时间延迟. 有效时间单位是 “ns”，“us”（或 “μs”），“ms”，“s”，“m”，“h”. </td>
</tr>
<tr>
<td>rollback</td>
<td></td>
<td>false</td>
<td>如果这是真的，那么这是一个请求，可以终止已经部分推出的现有部署.它有效地逆转了当前和下一步，并进行了一次 rollout </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema'.</td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>5m0s</td>
<td>最多等待复制控制器在放弃之前更新的时间. 有效时间单位是 “ns”，“us”（或 “μs”），“ms”，“s”，“m”，“h”. </td>
</tr>
<tr>
<td>update-period</td>
<td></td>
<td>1m0s</td>
<td>更新 pod 之间等待的时间. 有效时间单位是 “ns”，“us”（或 “μs”），“ms”，“s”，“m”，“h”. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="rollout">rollout</h1>
<blockquote class="code-block example">
<p> 回滚到以前的部署.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">undo</span> deployment/<span class="hljs-keyword">abc</span>
</code></pre>
<p>使用诸如 “kubectl rollout undo deployment / abc” 之类的子命令来管理部署</p>
<h3 id="usage">Usage</h3>
<p><code>$ rollout SUBCOMMAND</code></p>
<hr>
<h2 id="-em-history-em-"><em>history</em></h2>
<blockquote class="code-block example">
<p> 查看部署的 rollout 历史</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">history</span> deployment/<span class="hljs-keyword">abc</span>
</code></pre>
<blockquote class="code-block example">
<p> 查看部署修订3的详细信息</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">history</span> deployment/<span class="hljs-keyword">abc</span> --revision=<span class="hljs-number">3</span>
</code></pre>
<p>查看以前的推出版本和配置.</p>
<h3 id="usage">用法</h3>
<p><code>$ history (TYPE NAME | TYPE/NAME) [flags]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>revision</td>
<td></td>
<td>0</td>
<td>请参阅详细信息，包括指定版本的 pod 模板 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-pause-em-"><em>pause</em></h2>
<blockquote class="code-block example">
<p>将 nginx 部署标记为暂停.部署的任何当前状态都将继续其功能，只要部署暂停，对部署的新更新就不会产生任何效果.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-built_in">pause</span> deployment/nginx
</code></pre>
<p>将所提供的资源标记为暂停 </p>
<p>暂停的资源不会由控制器来协调.使用 “kubectl rollout resume” 恢复暂停的资源.目前，只有部署支持被暂停.</p>
<h3 id="usage">用法</h3>
<p><code>$ pause RESOURCE</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件.</td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-resume-em-"><em>resume</em></h2>
<blockquote class="code-block example">
<p> 恢复已暂停的部署.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">resume</span> deployment/nginx
</code></pre>
<p>恢复暂停的资源. </p>
<p>暂停的资源不会由控制器来协调.通过恢复资源，我们允许重新协调.目前只有部署支持被恢复.</p>
<h3 id="usage">用法</h3>
<p><code>$ resume RESOURCE</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件.</td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-status-em-"><em>status</em></h2>
<blockquote class="code-block example">
<p>观察部署的部署状态.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">status</span> deployment/nginx
</code></pre>
<p>显示该产品的发布状态.</p>
<p>默认情况下，“rollout status” 将会在最后的推出状态下观看，直到完成. 如果您不想等待完成，那么您可以使用 --watch = false. 请注意，如果新的推出从中间开始，则 “rollout status” 将继续观看最新版本. 如果要针对特定的修订版本进行修复，并且如果由另一个版本进行翻译，则中止它，请使用 --revision = N，其中 N 是您需要注意的修订版本.
</p>
<h3 id="usage">用法</h3>
<p><code>$ status (TYPE NAME | TYPE/NAME) [flags]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件.</td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td> 
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用.</td>
</tr>
<tr>
<td>revision</td>
<td></td>
<td>0</td>
<td>针对显示其状态的特定修订. 默认为 0（最后一个版本）. </td>
</tr>
<tr>
<td>watch</td>
<td>w</td>
<td>true</td>
<td>观察推出的状态，直到完成. </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-undo-em-"><em>undo</em></h2>
<blockquote class="code-block example">
<p>回滚到以前的部署</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">undo</span> deployment/<span class="hljs-keyword">abc</span>
</code></pre>
<blockquote class="code-block example">
<p>回滚到部署修订3</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout <span class="hljs-keyword">undo</span> deployment/<span class="hljs-keyword">abc</span> --<span class="hljs-keyword">to</span>-revision=<span class="hljs-number">3</span>
</code></pre>
<blockquote class="code-block example">
<p>使用 dry-run 回滚到以前的部署</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl rollout undo --dry-<span class="hljs-keyword">run</span><span class="bash">=<span class="hljs-literal">true</span> deployment/abc</span>
</code></pre>
<p>回滚到先前的部署.</p>
<h3 id="usage">用法</h3>
<p><code>$ undo (TYPE NAME | TYPE/NAME) [flags]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td> 
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>to-revision</td>
<td></td>
<td>0</td>
<td>对回滚的修改.默认为0(最后一次修订). </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="scale">scale</h1>
<blockquote class="code-block example">
<p> 将名为 “foo” 的副本集缩放为3.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl scale <span class="hljs-comment">--replicas=3 rs/foo</span>
</code></pre>
<blockquote class="code-block example">
<p> 缩放由 “foo.yaml” 中指定的类型和名称标识的资源到3.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl scale <span class="hljs-comment">--replicas=3 -f foo.yaml</span>
</code></pre>
<blockquote class="code-block example">
<p> 如果名为 “mysql”的部署当前大小为2，则将 mysql 缩放到3.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">scale</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">current</span><span class="hljs-literal">-</span><span class="hljs-comment">replicas=2</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">replicas=3</span> <span class="hljs-comment">deployment/mysql</span>
</code></pre>
<blockquote class="code-block example">
<p>缩放多个复制控制器.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">scale</span> --replicas=<span class="hljs-number">5</span> rc/foo rc/<span class="hljs-built_in">bar</span> rc/baz
</code></pre>
<blockquote class="code-block example">
<p> 缩放名为 “cron” 的 job 为3.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl scale <span class="hljs-comment">--replicas=3 job/cron</span>
</code></pre>
<p>为一个 Deployment, ReplicaSet, Replication Controller, 或 Job 设置新的大小.</p>
<p>缩放还允许用户为缩放操作指定一个或多个前提条件.</p>
<p>如果指定了 --current-replicas 或 --resource-version，则在尝试缩放比例之前验证它，并且在将比例发送到服务器时确保前提条件成立.</p>
<h3 id="usage">用法</h3>
<p><code>$ scale [--resource-version=version] [--current-replicas=count] --replicas=COUNT (-f FILENAME | TYPE NAME)</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>current-replicas</td>
<td></td>
<td>-1</td>
<td>当前尺寸的前提条件.要求资源的当前大小与此值匹配以便缩放.</td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL 到标识资源以设置新大小的文件.</td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出模式. 使用 “-o name” 用于较短的输出（资源/名称）.</td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>replicas</td>
<td></td>
<td>-1</td>
<td>新的期望数量的副本.必需的.</td>
</tr>
<tr>
<td>resource-version</td>
<td></td>
<td></td>
<td>资源版本的先决条件.需要当前的资源版本匹配这个值以进行扩展.</td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>0s</td>
<td>在放弃比例操作之前等待的时间长度，零意味着不要等待. 任何其他值应包含相应的时间单位（例如 1s，2m，3h）. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="set">set</h1>
<p>配置应用资源 </p>
<p>这些命令可帮助您更改现有的应用程序资源.</p>
<h3 id="usage">用法</h3>
<p><code>$ set SUBCOMMAND</code></p>
<hr>
<h2 id="-em-image-em-"><em>image</em></h2>
<blockquote class="code-block example">
<p> 将部署的 nginx 容器映像设置为 “nginx：1.9.1”，将其 busybox 容器映像设置为 “busybox”.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl set image deployment/nginx <span class="hljs-attr">busybox=busybox</span> <span class="hljs-attr">nginx=nginx:1.9.1</span>
</code></pre>
<blockquote class="code-block example">
<p> 将所有 deployment 和 rc 的 nginx 容器的映像更新为 “nginx：1.9.1”</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">set</span> image deployments,rc nginx=nginx:<span class="hljs-number">1.9</span><span class="hljs-number">.1</span> <span class="hljs-comment">--all</span>
</code></pre>
<blockquote class="code-block example">
<p>将 daemonset abc 的所有容器的 image 更新为 “nginx：1.9.1”</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">set</span> image <span class="hljs-comment">daemonset abc *=nginx:1.9.1</span>
</code></pre>
<blockquote class="code-block example">
<p>从本地文件更新 nginx 容器映像的打印结果（以 yaml 格式），而不会触发服务器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">set</span> image -f path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.yaml nginx=nginx:<span class="hljs-number">1.9</span><span class="hljs-number">.1</span> <span class="hljs-comment">--local -o yaml</span>
</code></pre>
<p>更新现有的容器 inage 的资源.</p>
<p>可能的资源包括（不区分大小写）：</p>
<p>  pod (po), replicationcontroller (rc), deployment (deploy), daemonset (ds), job, replicaset (rs)</p>
<h3 id="usage">用法</h3>
<p><code>$ image (-f FILENAME | TYPE NAME) CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>选择指定资源类型的命名空间中的所有资源</td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件.
</td>
</tr>
<tr>
<td>local</td>
<td></td>
<td>false</td>
<td>如果为 true，则设置 image 将不会与 api-server 联系，而是在本地运行. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模版 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤</td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）.</td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）</td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-resources-em-"><em>resources</em></h2>
<blockquote class="code-block example">
<p> 将部署 nginx 容器 cpu 限制设置为 “200m” 和 “512Mi” 的存储器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">set</span> resources deployment nginx -c=nginx <span class="hljs-comment">--limits=cpu=200m,memory=512Mi</span>
</code></pre>
<blockquote class="code-block example">
<p>为 nginx 中的所有容器设置资源请求和限制</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl set resources deployment nginx --limits=cpu=<span class="hljs-number">200</span>m,memory=<span class="hljs-number">512</span>Mi --requests=cpu=<span class="hljs-number">100</span>m,memory=<span class="hljs-number">256</span>Mi
</code></pre>
<blockquote class="code-block example">
<p> 删除 nginx 中容器资源的资源请求</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl set resources deployment nginx --limits=cpu=<span class="hljs-number">0</span>,memory=<span class="hljs-number">0</span> --requests=cpu=<span class="hljs-number">0</span>,memory=<span class="hljs-number">0</span>
</code></pre>
<blockquote class="code-block example">
<p>打印从本地更新 nginx 容器限制的结果（以 yaml 格式），而不会触发服务器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">set</span> resources -f path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.yaml <span class="hljs-comment">--limits=cpu=200m,memory=512Mi --local -o yaml</span>
</code></pre>
<p>为定义 pod 模板的任何资源指定计算资源要求（cpu，内存）. 如果一个 pod 已经被成功安排，它将保证所请求的资源数量，但可能会突破其指定的限制. </p>
<p>对于每个计算资源，如果指定了限制并省略了请求，则该请求将默认为限制. </p>
<p>可能的资源包括（不区分大小写）：replicationcontroller，deployment，daemonset，job，replicaset.</p>
<h3 id="usage">用法</h3>
<p><code>$ resources (-f FILENAME | TYPE NAME)  ([--limits=LIMITS &amp; --requests=REQUESTS]</code></p>
<h3 id="flags">标记</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>选择指定资源类型的命名空间中的所有资源. </td>
</tr>
<tr>
<td>containers</td>
<td>c</td>
<td>*</td>
<td>在选择的pod模板中要更改的容器的名称，所有的容器都是默认选择的 -- 可以使用通配符 </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，标识要从服务器获取的资源的文件. </td>
</tr>
<tr>
<td>limits</td>
<td></td>
<td></td>
<td>资源需求请求此容器. 例如，'cpu = 100m，memory = 256Mi'. 请注意，服务器端组件可能会根据服务器配置分配请求，例如限制范围. </td>
</tr>
<tr>
<td>local</td>
<td></td>
<td>false</td>
<td>如果为 true，设置资源将不会与 api-server 联系，而是在本地运行. </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用.</td>
</tr>
<tr>
<td>requests</td>
<td></td>
<td></td>
<td>资源需求请求此容器. 例如，'cpu = 100m，memory = 256Mi'. 请注意，服务器端组件可能会根据服务器配置分配请求，例如限制范围.</td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤 </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
</tbody>
</table>

<h1 id="-strong-declarative-app-management-strong-"><strong>声明 APP 管理</strong></h1>
<hr>
<h1 id="apply">apply</h1>
<blockquote class="code-block example">
<p>将 pod.json 中的配置应用于 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl apply <span class="hljs-_">-f</span> ./pod.json
</code></pre>
<blockquote class="code-block example">
<p>将传入 stdin 的 JSON 应用到 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">cat pod.json | <span class="hljs-type">kubectl</span> <span class="hljs-built_in">apply</span> -f -
</code></pre>
<blockquote class="code-block example">
<p>注意：--prune 仍然在 Alpha 版本 ＃应用配置在与标签 app = nginx 匹配的 manifest.yaml 中，并删除文件中没有的所有其他资源，并匹配标签 app = nginx.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl apply --prune <span class="hljs-_">-f</span> manifest.yaml <span class="hljs-_">-l</span> app=nginx
</code></pre>
<blockquote class="code-block example">
<p>在 manifest.yaml 中应用配置，并删除文件中不存在的所有其他配置文件.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">apply</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">prune</span> <span class="hljs-literal">-</span><span class="hljs-comment">f</span> <span class="hljs-comment">manifest</span><span class="hljs-string">.</span><span class="hljs-comment">yaml</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">all</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">prune</span><span class="hljs-literal">-</span><span class="hljs-comment">whitelist=core/v1/ConfigMap</span>
</code></pre>
<p>通过文件名或 stdin 将配置应用于资源. 必须指定资源名称. 如果尚不存在，将创建此资源. 要使用 'apply'，始终使用 'apply' 或 'create --save-config' 创建资源.</p>
<p>JSON 和 YAML 格式被接受. </p>
<p>Alpha 免责声明：--prune 功能尚未完成. 不要使用，除非你知道当前状态是什么.详情请看 <a href="https://issues.k8s.io/34274">https://issues.k8s.io/34274</a>.</p>
<h3 id="usage">用法</h3>
<p><code>$ apply -f FILENAME</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名字</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>[-all] 选择所有指定的资源. </td>
</tr>
<tr>
<td>cascade</td>
<td></td>
<td>true</td>
<td>只有在修剪或强制请求时才有关系. 如果为真，则级联删除由已删除或已删除的资源（例如由 ReplicationController 创建的 Pods）管理的资源. </td>
</tr>
<tr>
<td>dry-run</td>
<td></td>
<td>false</td>
<td>如果为 true，则只打印要发送的对象，而不发送. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL 到包含要应用的配置的文件 </td>
</tr>
<tr>
<td>force</td>
<td></td>
<td>false</td>
<td>当 PATCH 遇到冲突并重试5次时，删除并重新创建指定的资源. </td>
</tr>
<tr>
<td>grace-period</td>
<td></td>
<td>-1</td>
<td>只有在修剪或强制请求时才有关系.一段时间内，在删除或删除资源时，可以优雅地终止.如果为负，则忽略. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>overwrite</td>
<td></td>
<td>true</td>
<td>通过使用修改后的配置值自动解决修改和实时配置之间的冲突. </td>
</tr>
<tr>
<td>prune</td>
<td></td>
<td>false</td>
<td>自动删除未出现在配置中的资源对象，并通过 apply 或create -save-config 创建. 应该与 -l 或 --all 一起使用. </td>
</tr>
<tr>
<td>prune-whitelist</td>
<td></td>
<td>[]</td>
<td>用 --prune 覆盖 <group / version / kind> 的默认白名单 </td>
</tr>
<tr>
<td>record</td>
<td></td>
<td>false</td>
<td>在资源注释中记录当前的 kubectl 命令. 如果设置为 false，则不要记录命令. 如果设置为 true，请记录命令. 如果未设置，则仅在已存在的注释值时才更新. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema' </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤 </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串.</td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>0s</td>
<td>仅适用于强制请求的情况下. 在放弃旧资源的删除之前等待的时间长度为零表示从对象的大小确定超时. 任何其他值应包含相应的时间单位（例如1s，2m，3h）.</td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入. </td>
</tr>
</tbody>
</table>

<h1 id="-strong-working-with-apps-strong-"><strong>使用 APP 程序</strong></h1>
<p>本节包含检查和调试应用的命令.</p>
<ul>
<li><code>logs</code> 将从指定的 pod 和 container 中打印日志.</li>
<li><code>exec</code> 可以用于在 pod 和 container 上获取交互式 shell.</li>
<li><code>describe</code> 将打印关于给定资源的调试信息.</li>
</ul>
<hr>
<h1 id="attach">attach</h1>
<blockquote class="code-block example">
<p> 从运行的 pod 123456-7890 获得输出，默认使用第一个容器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-section">attach</span> <span class="hljs-number">123456</span><span class="hljs-number">-7890</span>
</code></pre>
<blockquote class="code-block example">
<p> 从 pod 123456-7890 中获得输出</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-section">attach</span> <span class="hljs-number">123456</span><span class="hljs-number">-7890</span> -c ruby-container
</code></pre>
<blockquote class="code-block example">
<p> 切换到原始终端模式，从 pod 123456-7890 发送 stdin 到 ruby-container 中的 'bash'，并将 stdout / stderr 从 'bash'中发送回客户端</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-section">attach</span> <span class="hljs-number">123456</span><span class="hljs-number">-7890</span> -c ruby-container -i -t
</code></pre>
<p>附加到已经在现有容器中运行的进程.</p>
<h3 id="usage">用法</h3>
<p><code>$ attach POD -c CONTAINER</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>container</td>
<td>c</td>
<td></td>
<td>容器名称. 如果省略，将选择 pod 中的第一个容器. </td>
</tr>
<tr>
<td>stdin</td>
<td>i</td>
<td>false</td>
<td>将 stdin 传递给容器 </td>
</tr>
<tr>
<td>tty</td>
<td>t</td>
<td>false</td>
<td>Stdin 是一个 TTY </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="cp">cp</h1>
<blockquote class="code-block example">
<p> !!!重要的提示!!! 需要在您的容器 image 中 'tar' 二进制文件. 如果 'tar' 不存在，'kubectl cp' 将失败. ＃将 /tmp/foo_dir 本地目录复制到 /tmp/bar_dir 在默认名称空间的远程 pod 中</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl cp /tmp/foo_dir &lt;some-pod&gt;<span class="hljs-symbol">:/tmp/bar_dir</span>
</code></pre>
<blockquote class="code-block example">
<p>在一个特定的容器中，将 /tmp/foo 本地文件复制到 /tmp/bar.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl cp <span class="hljs-meta-keyword">/tmp/</span>foo <span class="hljs-params">&lt;some-pod&gt;</span>:<span class="hljs-meta-keyword">/tmp/</span>bar -c <span class="hljs-params">&lt;specific-container&gt;</span>
</code></pre>
<blockquote class="code-block example">
<p> 将 /tmp/foo 本地文件复制到命名空间 <some-namespace> 中远程 pod 中的 /tmp/bar</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl cp <span class="hljs-meta-keyword">/tmp/</span>foo <span class="hljs-params">&lt;some-namespace&gt;</span>/<span class="hljs-params">&lt;some-pod&gt;</span>:<span class="hljs-meta-keyword">/tmp/</span>bar
</code></pre>
<blockquote class="code-block example">
<p>将 /tmp/foo 从一个远程的 pod 复制到 /tmp/bar</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl cp <span class="hljs-params">&lt;some-namespace&gt;</span>/<span class="hljs-params">&lt;some-pod&gt;</span>:<span class="hljs-meta-keyword">/tmp/</span>foo <span class="hljs-meta-keyword">/tmp/</span>bar
</code></pre>
<p>将文件和目录复制到容器中.</p>
<h3 id="usage">用法</h3>
<p><code>$ cp &lt;file-spec-src&gt; &lt;file-spec-dest&gt;</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>container</td>
<td>c</td>
<td></td>
<td>容器名称. 如果省略，将选择 pod 中的第一个容器 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="describe">describe</h1>
<blockquote class="code-block example">
<p>描述一个节点</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl describe nodes kubernetes-<span class="hljs-keyword">node</span><span class="hljs-title">-emt8</span>.c.myproject.internal
</code></pre>
<blockquote class="code-block example">
<p>描述一个 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">describe</span> pods/nginx
</code></pre>
<blockquote class="code-block example">
<p>描述在 “pod.json” 中类型和名称标识的 pod.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl describe <span class="hljs-_">-f</span> pod.json
</code></pre>
<blockquote class="code-block example">
<p>描述所有的 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl describe pods</span>
</code></pre>
<blockquote class="code-block example">
<p> 通过标签 name=myLabel 描述 pod</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">describe</span> po -l <span class="hljs-keyword">name</span>=myLabel
</code></pre>
<blockquote class="code-block example">
<p> 描述由 'frontend' 复制控制器管理的所有 pod（rc 创建的 pods 获取 rc 的名称作为 pod 中的前缀名称）.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl describe pods frontend</span>
</code></pre>
<p>显示特定资源或资源组的详细信息. 该命令将许多 API 调用合并在一起，以形成给定资源或资源组的详细描述. </p>
<p>  $ kubectl describe TYPE NAME_PREFIX</p>
<p>首先要检查类型和名称前缀的精确匹配.如果不存在这样的资源，它将为每个具有名称前缀前缀的资源输出详细信息. </p>
<p>有效的资源类型包括: </p>
<ul>
<li>clusters (只适用于联邦 apiservers)  </li>
<li>componentstatuses (又名 &#39;cs&#39;)  </li>
<li>configmaps (又名 &#39;cm&#39;)  </li>
<li>daemonsets (又名 &#39;ds&#39;)  </li>
<li>deployments (又名 &#39;deploy&#39;)  </li>
<li>endpoints (又名 &#39;ep&#39;)  </li>
<li>events (又名 &#39;ev&#39;)  </li>
<li>horizontalpodautoscalers (又名 &#39;hpa&#39;)  </li>
<li>ingresses (又名 &#39;ing&#39;)  </li>
<li>jobs  </li>
<li>limitranges (又名 &#39;limits&#39;)  </li>
<li>namespaces (又名 &#39;ns&#39;)  </li>
<li>networkpolicies  </li>
<li>nodes (又名 &#39;no&#39;)  </li>
<li>persistentvolumeclaims (又名 &#39;pvc&#39;)  </li>
<li>persistentvolumes (又名 &#39;pv&#39;)  </li>
<li>pods (又名 &#39;po&#39;)  </li>
<li>podsecuritypolicies (又名 &#39;psp&#39;)  </li>
<li>podtemplates  </li>
<li>replicasets (又名 &#39;rs&#39;)  </li>
<li>replicationcontrollers (又名 &#39;rc&#39;)  </li>
<li>resourcequotas (又名 &#39;quota&#39;)  </li>
<li>secrets  </li>
<li>serviceaccounts (又名 &#39;sa&#39;)  </li>
<li>services (又名 &#39;svc&#39;)  </li>
<li>statefulsets  </li>
<li>storageclasses  </li>
<li>thirdpartyresources</li>
</ul>
<h3 id="usage">用法</h3>
<p><code>$ describe (-f FILENAME | TYPE [NAME_PREFIX | -l label] | TYPE/NAME)</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all-namespaces</td>
<td></td>
<td>false</td>
<td>如果存在，请在所有命名空间中列出所请求的对象. 当前上下文中的命名空间即使用 --namespace 指定也将被忽略. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL 到包含要描述的资源的文件.</td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义.[默认为 true]</td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤</td>
</tr>
<tr>
<td>show-events</td>
<td></td>
<td>true</td>
<td>如果为 true，则显示与描述的对象相关的事件. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="exec">exec</h1>
<blockquote class="code-block example">
<p> 从 pod 123456-7890 运行 'date' 输出，默认使用第一个容器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">exec</span> <span class="hljs-number">123456</span><span class="hljs-number">-7890</span> <span class="hljs-built_in">date</span>
</code></pre>
<blockquote class="code-block example">
<p> 从 pod 123456-7890 获取在 ruby-containe r中运行 'date' 的输出</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">exec</span> <span class="hljs-number">123456</span><span class="hljs-number">-7890</span> -c ruby-<span class="hljs-keyword">container</span> <span class="hljs-keyword">date</span>
</code></pre>
<blockquote class="code-block example">
<p> 切换到原始终端模式，从 pod 123456-7890 发送 stdin 到 ruby-container 中的 'bash'，并将 stdout/stderr 从 'bash' 发送回客户端.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl exec <span class="hljs-number">123456</span><span class="hljs-number">-7890</span> -c ruby-container -i -t -- bash -il
</code></pre>
<p>在容器中执行命令.</p>
<h3 id="usage">用法</h3>
<p><code>$ exec POD [-c CONTAINER] -- COMMAND [args...]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>container</td>
<td>c</td>
<td></td>
<td>容器名称. 如果省略，将选择 pod 中的第一个容器 </td>
</tr>
<tr>
<td>pod</td>
<td>p</td>
<td></td>
<td>Pod 名称 </td>
</tr>
<tr>
<td>stdin</td>
<td>i</td>
<td>false</td>
<td>将 stdin 传递给容器 </td>
</tr>
<tr>
<td>tty</td>
<td>t</td>
<td>false</td>
<td>Stdin 是一个 TTY</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="logs">logs</h1>
<blockquote class="code-block example">
<p>从 pod nginx 返回快照日志，只使用一个容器</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl logs nginx</span>
</code></pre>
<blockquote class="code-block example">
<p>从 pod web-1 返回先前终止的 ruby 容器日志的快照</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl logs -<span class="hljs-selector-tag">p</span> -c ruby web-<span class="hljs-number">1</span>
</code></pre>
<blockquote class="code-block example">
<p>开始在 pod web-1 中流式传输 ruby 容器的日志</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl logs <span class="hljs-_">-f</span> -c ruby web-1
</code></pre>
<blockquote class="code-block example">
<p>仅显示 pod nginx 中最近的20行输出</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl logs <span class="hljs-comment">--tail=20 nginx</span>
</code></pre>
<blockquote class="code-block example">
<p>显示最后一小时内写的 pod nginx 的所有日志</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl logs <span class="hljs-comment">--since=1h nginx</span>
</code></pre>
<p>在一个 pod 打印容器的日志. 如果 pod 只有一个容器，则容器名称是可选的.</p>
<h3 id="usage">用法</h3>
<p><code>$ logs [-f] [-p] POD [-c CONTAINER]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>container</td>
<td>c</td>
<td></td>
<td>打印这个容器的日志</td>
</tr>
<tr>
<td>follow</td>
<td>f</td>
<td>false</td>
<td>指定日志是否应该流式传输. </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>interactive</td>
<td></td>
<td>false</td>
<td>如果为 true，则在需要时提示用户输入.</td>
</tr>
<tr>
<td>limit-bytes</td>
<td></td>
<td>0</td>
<td>要返回的最大字节数. 默认为无限制.</td>
</tr>
<tr>
<td>previous</td>
<td>p</td>
<td>false</td>
<td>如果为 true，则打印容器中前一个容器实例的日志（如果存在）. </td>
</tr>
<tr>
<td>since</td>
<td></td>
<td>0s</td>
<td>只返回比相对持续时间更久的日志，比如5s、2m或3h.默认为所有日志.只有一段时间可以使用. </td>
</tr>
<tr>
<td>since-time</td>
<td></td>
<td></td>
<td>仅在特定日期之后返回日志（RFC3339）. 默认为所有日志. 只能使用以前的一个时间. </td>
</tr>
<tr>
<td>tail</td>
<td></td>
<td>-1</td>
<td>要显示的最近日志文件的行. 默认为-1，显示所有日志行. </td>
</tr>
<tr>
<td>timestamps</td>
<td></td>
<td>false</td>
<td>在日志输出中的每一行中包含时间戳.</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="port-forward">port-forward</h1>
<blockquote class="code-block example">
<p>在本地端口5000和6000上监听，将数据转发到 pod 的5000和6000端口</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl port-forward mypod <span class="hljs-number">5000</span> <span class="hljs-number">6000</span>
</code></pre>
<blockquote class="code-block example">
<p>在本地端口8888上监听，转发到 pod 的5000端口</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">port-forward</span> <span class="hljs-selector-tag">mypod</span> 8888<span class="hljs-selector-pseudo">:5000</span>
</code></pre>
<blockquote class="code-block example">
<p>在本地随机端口上监听，转发到 pod 中的5000端口</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">port-forward</span> <span class="hljs-selector-tag">mypod</span> <span class="hljs-selector-pseudo">:5000</span>
</code></pre>
<blockquote class="code-block example">
<p>在本地随机端口上侦听，转发到 pod 中的5000端口</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">port-forward</span>  <span class="hljs-selector-tag">mypod</span> 0<span class="hljs-selector-pseudo">:5000</span>
</code></pre>
<p>将一个或多个本地端口转发到 pod.</p>
<h3 id="usage">用法</h3>
<p><code>$ port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod</td>
<td>p</td>
<td></td>
<td>Pod 名称 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="proxy">proxy</h1>
<blockquote class="code-block example">
<p>在8011端口上运行代理到 kubernetes apiserver，从 ./local/www/ 提供静态内容</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-comment">kubectl</span> <span class="hljs-comment">proxy</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8011</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">www=</span><span class="hljs-string">.</span><span class="hljs-comment">/local/www/</span>
</code></pre>
<blockquote class="code-block example">
<p>在任意本地端口上运行代理到 kubernetes apiserver. 选择的服务器端口将被输出到 stdout.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl proxy <span class="hljs-comment">--port=0</span>
</code></pre>
<blockquote class="code-block example">
<p> 运行代理到 kubernetes apiserver，将 api 前缀改为 k8s-api, 这使得例如本地主机可用的 pod api:8011/k8s-api/v1/pods/</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl proxy <span class="hljs-comment">--api-prefix=/k8s-api</span>
</code></pre>
<p>要代理所有的 kubernetes api，没有别的，请使用： </p>
<p>  $ kubectl proxy --api-prefix=/</p>
<p>仅代理 kubernetes api 的一部分以及一些静态文件： </p>
<p>  $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/</p>
<p>以上可以让你 &#39;curl localhost:8001/api/v1/pods&#39;. </p>
<p>要在不同的 root 处代替整个 kubernetes api，请使用： </p>
<p>  $ kubectl proxy --api-prefix=/custom/</p>
<p>以上可以让你 &#39;curl localhost:8001/custom/api/v1/pods&#39;</p>
<h3 id="usage">用法</h3>
<p><code>$ proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>accept-hosts</td>
<td></td>
<td>^localhost$,^127.0.0.1$,^[::1]$</td>
<td>代理应该接受的主机的正则表达式. </td>
</tr>
<tr>
<td>accept-paths</td>
<td></td>
<td>^/.*</td>
<td>代理应接受的路径的正则表达式.</td>
</tr>
<tr>
<td>address</td>
<td></td>
<td>127.0.0.1</td>
<td>用于服务的IP地址.</td>
</tr>
<tr>
<td>api-prefix</td>
<td></td>
<td>/</td>
<td>前缀服务于下面的代理 API. </td>
</tr>
<tr>
<td>disable-filter</td>
<td></td>
<td>false</td>
<td>如果为 true，请禁用代理中的请求过滤. 当与可访问端口一起使用时，这是危险的，并且可以让您容易受到 XSRF 攻击. </td>
</tr>
<tr>
<td>port</td>
<td>p</td>
<td>8001</td>
<td>用来运行代理的端口.设置为0来选择一个随机的端口.</td>
</tr>
<tr>
<td>reject-methods</td>
<td></td>
<td>POST,PUT,PATCH</td>
<td>代理应该拒绝的 HTTP 方法的正则表达式. </td>
</tr>
<tr>
<td>reject-paths</td>
<td></td>
<td>^/api/.<em>/pods/.</em>/exec,^/api/.<em>/pods/.</em>/attach</td>
<td>代理应该拒绝的路径的正则表达式. </td>
</tr>
<tr>
<td>unix-socket</td>
<td>u</td>
<td></td>
<td>用于运行代理的 Unix 套接字. </td>
</tr>
<tr>
<td>www</td>
<td>w</td>
<td></td>
<td>还可以在指定的前缀下提供来自给定目录的静态文件. </td>
</tr>
<tr>
<td>www-prefix</td>
<td>P</td>
<td>/static/</td>
<td>如果指定静态文件目录，则使用前缀来提供静态文件. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="top">top</h1>
<p>显示资源（CPU /内存/存储）使用情况. </p>
<p>top 命令允许您查看节点或 pod 的资源消耗情况.</p>
<h3 id="usage">用法</h3>
<p><code>$ top</code></p>
<hr>
<h2 id="-em-node-em-"><em>node</em></h2>
<blockquote class="code-block example">
<p> 显示所有节点的指标</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl top <span class="hljs-keyword">node</span><span class="hljs-title"></span>
</code></pre>
<blockquote class="code-block example">
<p> 显示给定节点的指标</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl top <span class="hljs-keyword">node</span> <span class="hljs-title">NODE_NAME</span>
</code></pre>
<p>显示资源（CPU /内存/存储）节点的使用情况.</p>
<p>top-node 命令允许您查看节点的资源消耗.</p>
<h3 id="usage">用法</h3>
<p><code>$ node [NAME | -l label]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-pod-em-"><em>pod</em></h2>
<blockquote class="code-block example">
<p> 显示默认命名空间中所有 pod 的指标</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">top</span> pod
</code></pre>
<blockquote class="code-block example">
<p> 显示指定命名空间中所有 pod 的指标</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl top pod --<span class="hljs-keyword">namespace</span>=NAMESPACE
</code></pre>
<blockquote class="code-block example">
<p> 显示给定 pod 及其容器的指标</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl top pod POD_NAME <span class="hljs-comment">--containers</span>
</code></pre>
<blockquote class="code-block example">
<p>显示标签 name = myLabel 定义的 pod 的指标</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl top pod -l <span class="hljs-built_in">name</span>=myLabel
</code></pre>
<p>显示 pod 的资源（CPU /内存/存储）使用. </p>
<p>'top pod' 命令允许您查看 pod 的资源消耗. </p>
<p>由于度量管道的延迟，它们可能在创建后的几分钟内不可用.</p>
<h3 id="usage">用法</h3>
<p><code>$ pod [NAME | -l label]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all-namespaces</td>
<td></td>
<td>false</td>
<td>如果存在，请在所有命名空间中列出所请求的对象. 当前上下文中的命名空间即使用 --namespace 指定也将被忽略. </td>
</tr>
<tr>
<td>containers</td>
<td></td>
<td>false</td>
<td>如果存在，打印容器在 pod 中的使用. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤</td>
</tr>
</tbody>
</table>

<h1 id="-strong-cluster-management-strong-"><strong>集群管理</strong></h1>
<hr>
<h1 id="api-versions">api-versions</h1>
<h3 id="usage">用法</h3>
<p><code>$ api-versions</code></p>
<hr>
<h1 id="certificate">certificate</h1>
<h3 id="usage">用法</h3>
<p><code>$ certificate SUBCOMMAND</code></p>
<hr>
<h2 id="-em-approve-em-"><em>approve</em></h2>
<p>批准证书签名请求. </p>
<p>kubectl 证书批准允许集群管理员批准证书签名请求（CSR）. 此操作将告知证书签名控制器向请求者颁发证书，并具有 CSR 中请求的属性. </p>
<p>安全注意事项：根据请求的属性，颁发的证书可能会授权请求者访问集群资源或作为请求的身份进行身份验证. 在批准 CSR 之前，请确保您了解签名的证书可以做什么.</p>
<h3 id="usage">用法</h3>
<p><code>$ approve (-f FILENAME | NAME)</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，以标识要更新的资源的文件 </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出模式. 使用 “-o name” 用于较短的输出（资源/名称）. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-deny-em-"><em>deny</em></h2>
<p>拒绝证书签名请求. </p>
<p>kubectl证书拒绝允许集群管理员拒绝证书签名请求（CSR）. 此操作会告知证书签名控制器不向请求者发出证书.</p>
<h3 id="usage">用法</h3>
<p><code>$ deny (-f FILENAME | NAME)</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>文件名，目录或 URL，以标识要更新的资源的文件 </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出模式. 使用 “-o name” 用于较短的输出（资源/名称）. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="cluster-info">cluster-info</h1>
<p>显示主机和服务的地址，标签为 kubernetes.io/cluster-service=true .要进一步调试和诊断群集问题，请使用 'kubectl cluster-info dump'.</p>
<h3 id="usage">用法</h3>
<p><code>$ cluster-info</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-dump-em-"><em>dump</em></h2>
<blockquote class="code-block example">
<p> 将当前群集状态转储到 stdout</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl</span> cluster-<span class="hljs-literal">info</span> dump
</code></pre>
<blockquote class="code-block example">
<p> 将当前集群状态转储到 /path/to/cluster-state</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl cluster-info <span class="hljs-keyword">dump</span> --output-directory=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/cluster-state</span>
</code></pre>
<blockquote class="code-block example">
<p> 将所有命名空间转储到 stdout</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl</span> cluster-<span class="hljs-literal">info</span> dump --all-namespaces
</code></pre>
<blockquote class="code-block example">
<p> 将一组命名空间转储到 /path/to/cluster-state</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">cluster</span>-info dump --namespaces <span class="hljs-keyword">default</span>,kube-<span class="hljs-keyword">system</span> --output-directory=/path/to/<span class="hljs-keyword">cluster</span>-state
</code></pre>
<p>转储集群信息适用于调试和诊断集群问题. 默认情况下，将所有内容转储到 stdout. 您可以选择使用 --output-directory 指定目录. 如果您指定一个目录，kubernetes 将在该目录中构建一组文件. 默认情况下，只会转储 “kube-system” 命名空间中的内容，但是您可以使用 --namespaces 标志切换到其他命名空间，也可以指定 --all 命名空间来转储所有命名空间.</p>
<p>该命令还将转储群集中所有 pod 的日志，这些日志根据命名空间和 pod 名称转储到不同的目录中.</p>
<h3 id="usage">用法</h3>
<p><code>$ dump</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all-namespaces</td>
<td></td>
<td>false</td>
<td>如果为 true，请转储所有命名空间. 如果为 true，则忽略名称空间. </td>
</tr>
<tr>
<td>namespaces</td>
<td></td>
<td>[]</td>
<td>用于转储的命名空间的逗号分隔列表. </td>
</tr>
<tr>
<td>output-directory</td>
<td></td>
<td></td>
<td>在哪里输出文件. 如果为空或' - '，使用stdout，否则在该目录中创建目录层次结构 .</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="cordon">cordon</h1>
<blockquote class="code-block example">
<p> 标记节点 “foo” 作为不可调度的.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl cordon foo</span>
</code></pre>
<p>将节点标记为不可调度.</p>
<h3 id="usage">用法</h3>
<p><code>$ cordon NODE</code></p>
<hr>
<h1 id="drain">drain</h1>
<blockquote class="code-block example">
<p>耗尽节点 “foo”，即使有一个没有被 ReplicationController，ReplicaSet，Job，DaemonSet 或 StatefulSet 管理的 pod.
</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">$ kubectl drain foo <span class="hljs-comment">--force</span>
</code></pre>
<blockquote class="code-block example">
<p>如上所述，如果没有由 ReplicationController，ReplicaSet，Job，DaemonSet 或 StatefulSet 管理 pod，并且使用15分钟的宽限期，则中止.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">$ kubectl drain foo <span class="hljs-comment">--grace-period=900</span>
</code></pre>
<p>为耗尽节点的维护做准备 </p>
<p>给定的节点将被标记为不可调度，以防止新的 pods 到达. 如果 APIServer 支持 eviciton，'drain' 会驱散 pod (<a href="http://kubernetes.io/docs/admin/disruptions/">http://kubernetes.io/docs/admin/disruptions/</a>). 否则，将使用正常的 DELETE 删除 pod. “drain” 排除或删除除镜像 pod 之外的所有 pod（不能通过 API 服务器删除）. 如果有 DaemonSet 管理的 pod，那么在没有 --ignore-daemonsets 的情况下，drain 不会继续进行，并且不管它们是否都将删除任何 DaemonSet 管理的 pod，因为这些 pod 将被 DaemonSet 控制器立即替换，DaemonSet 控制器会忽略不可调度的标记. 如果没有任何一个 pods 是镜像 pod，或者也不是由 ReplicationController，ReplicaSet，DaemonSet，StatefulSet 或 Job 管理，那么 drain 不会删除任何 pod，除非你使用 --force. </p>
<p>“drain” 等待优雅终止. 在命令完成之前，您不应该在机器上运行. </p>
<p>当您准备好将该节点重新投入使用时，请使用 kubectl uncordon，这将使节点再次可调度. </p>
<p>! <a href="http://kubernetes.io/images/docs/kubectl_drain.svg">http://kubernetes.io/images/docs/kubectl_drain.svg</a></p>
<h3 id="usage">用法</h3>
<p><code>$ drain NODE</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>delete-local-data</td>
<td></td>
<td>false</td>
<td>即使有使用 emptyDir 的 pods(在节点耗尽时将删除的本地数据)，也要继续执行. </td>
</tr>
<tr>
<td>force</td>
<td></td>
<td>false</td>
<td>即使存在没有通过 ReplicationController，ReplicaSet，Job，DaemonSet 或 StatefulSet 管理的 pod 也要继续执行. </td>
</tr>
<tr>
<td>grace-period</td>
<td></td>
<td>-1</td>
<td>一段时间内，每一个 pod 都要优雅地终止.如果是负的，则将使用 pod 中指定的默认值. </td>
</tr>
<tr>
<td>ignore-daemonsets</td>
<td></td>
<td>false</td>
<td>忽略 DaemonSet 管理的 pods. </td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>0s</td>
<td>在放弃之前等待的时间，0意味着无限 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="taint">taint</h1>
<blockquote class="code-block example">
<p> 更新节点 “foo”，带有键 “dedicated” 和值 “special-user” 的污点并影响 “NoSchedule”. 如果带有该键和效果的污点已经存在，那么它的值就会按照指定替换.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl taint nodes foo dedicated=<span class="hljs-keyword">special</span>-user:NoSchedule
</code></pre>
<blockquote class="code-block example">
<p> 从节点 “foo” 中删除带有 “dedicated” 键的污点，如果存在，则执行 “NoSchedule”.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">taint</span> <span class="hljs-selector-tag">nodes</span> <span class="hljs-selector-tag">foo</span> <span class="hljs-selector-tag">dedicated</span><span class="hljs-selector-pseudo">:NoSchedule-</span>
</code></pre>
<blockquote class="code-block example">
<p> 从节点 “foo” 中删除所有 key 为 “dedicated” 的污点</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl</span> taint nodes foo dedicated-
</code></pre>
<p>更新一个或多个节点上的污点. </p>
<ul>
<li>一个污点由一个键、值和效果组成.作为一个参数，它被表示为 key=valueeffect.  </li>
<li>密钥必须以字母或数字开头，可能包含字母，数字，连字符，点和下划线，最多可包含253个字符.  </li>
<li>该值必须以字母或数字开头，可能包含字母，数字，连字符，点和下划线，最多可包含253个字符.  </li>
<li>效果必须是 NoSchedule 或 PreferNoSchedule. </li>
<li>目前污点只适用于节点.</li>
</ul>
<h3 id="usage">用法</h3>
<p><code>$ taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>选择集群中的所有节点 </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>overwrite</td>
<td></td>
<td>false</td>
<td>如果是真的，允许污点被覆盖，否则拒绝覆盖现有污点的污点更新. </td>
</tr>
<tr>
<td>schema-cache-dir</td>
<td></td>
<td>~/.kube/schema</td>
<td>如果在此目录中为非空，加载/存储缓存的 API 模式，则默认为 '$ HOME / .kube / schema'</td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤 </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）.</td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列）. </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
<tr>
<td>validate</td>
<td></td>
<td>true</td>
<td>如果为 true，请在发送之前使用模式验证输入 </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="uncordon">uncordon</h1>
<blockquote class="code-block example">
<p> 标记节点 “foo” 为可调度.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-variable">$ </span>kubectl uncordon foo
</code></pre>
<p>将节点标记为可调度.</p>
<h3 id="usage">用法</h3>
<p><code>$ uncordon NODE</code></p>

<h1 id="-strong-kubectl-settings-and-usage-strong-"><strong>KUBECTL 配置使用</strong></h1>
<hr>
<h1 id="completion">completion</h1>
<p>为给定的 shell ( bash 或 zsh )输出 shell 完成代码. </p>
<p>该命令打印 shell 代码，必须对其进行评估，以提供对 kubectl 命令的交互完成. </p>
<p>  $ source &lt;(kubectl completion bash)</p>
<p>将加载 bash 的 kubectl 完成代码. 请注意，这取决于 bash-completion 框架. 在采购 kubectl 完成之前必须采购. 在 Mac 上： </p>
<p>  $ brew install bash-completion
  $ source $(brew --prefix)/etc/bash_completion
  $ source &lt;(kubectl completion bash)</p>
<p>如果您使用 zsh [1]，以下将加载 kubectl zsh 完成： </p>
<p>  $ source &lt;(kubectl completion zsh)</p>
<p> [1] zsh完成仅在 zsh >= 5.2的版本中受支持</p>
<h3 id="usage">用法</h3>
<p><code>$ completion SHELL</code></p>
<hr>
<h1 id="config">config</h1>
<p>使用诸如 “kubectl config set current-context my-context” 之类的子命令修改 kubeconfig 文件</p>
<p>加载顺序遵循以下规则：</p>
<ol>
<li>如果设置了 --kubeconfig 标志，那么只有该文件被加载. 该标志只能设置一次，不会合并.  </li>
<li>如果设置了 $ KUBECONFIG 环境变量，那么它将使用路径列表（您的系统的常规路径分隔规则）. 这些路径被合并. 修改值时，会在定义该节的文件中进行修改. 创建一个值时，它将在存在的第一个文件中创建. 如果链中没有文件，则会创建列表中的最后一个文件.  </li>
<li>否则，$ {HOME}/.kube/config被使用，不会合并.</li>
</ol>
<h3 id="usage">用法</h3>
<p><code>$ config SUBCOMMAND</code></p>
<h3 id="flags">标记</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>kubeconfig</td>
<td></td>
<td></td>
<td>使用特定的 kubeconfig 文件 </td>
</tr> 
</tbody>
</table>
<hr>
<h2 id="-em-current-context-em-"><em>current-context</em></h2>
<blockquote class="code-block example">
<p>显示当前上下文</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">config</span> current-<span class="hljs-built_in">context</span>
</code></pre>
<p>显示当前上下文</p>
<h3 id="usage">用法</h3>
<p><code>$ current-context</code></p>
<hr>
<h2 id="-em-delete-cluster-em-"><em>delete-cluster</em></h2>
<h3 id="usage">用法</h3>
<p><code>$ delete-cluster NAME</code></p>
<hr>
<h2 id="-em-delete-context-em-"><em>delete-context</em></h2>
<h3 id="usage">用法</h3>
<p><code>$ delete-context NAME</code></p>
<hr>
<h2 id="-em-get-clusters-em-"><em>get-clusters</em></h2>
<h3 id="usage">用法</h3>
<p><code>$ get-clusters</code></p>
<hr>
<h2 id="-em-get-contexts-em-"><em>get-contexts</em></h2>
<blockquote class="code-block example">
<p> 列出您的 kubeconfig 文件中的所有上下文.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">config</span> <span class="hljs-built_in">get</span>-contexts
</code></pre>
<blockquote class="code-block example">
<p> 描述你的 kubeconfig 文件中的一个上下文.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">get-contexts</span> <span class="hljs-string">my-context</span>
</code></pre>
<p>显示 kubeconfig 文件中的一个或多个上下文.</p>
<h3 id="usage">用法</h3>
<p><code>$ get-contexts [(-o|--output=)name)]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-set-em-"><em>set</em></h2>
<p>在 kubeconfig 文件中设置单个值 </p>
<p>PROPERTY _NAME 是一个点分隔的名称，其中每个标记表示属性名称或地图键. 地图键可能不包含点. </p>
<p>PROPERTY _VALUE 是您要设置的新值. 诸如 'certificate-authority-data' 的二进制字段期望使用 base64 编码字符串，除非使用了 --set-raw-bytes 标志.</p>
<h3 id="usage">用法</h3>
<p><code>$ set PROPERTY_NAME PROPERTY_VALUE</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>set-raw-bytes</td>
<td></td>
<td>false</td>
<td>当写入[]字节的 PROPERTY_VALUE 时，直接写入给定的字符串而不进行 base64 解码. </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-set-cluster-em-"><em>set-cluster</em></h2>
<blockquote class="code-block example">
<p> 仅设置 e2e 群集条目上的服务器字段，而不触及其他值.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-cluster</span> <span class="hljs-string">e2e </span><span class="hljs-built_in">--server=https://1.2.3.4</span>
</code></pre>
<blockquote class="code-block example">
<p> 嵌入 e2e 集群条目的证书颁发机构数据.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-cluster</span> <span class="hljs-string">e2e </span><span class="hljs-built_in">--certificate-authority=~/.kube/e2e/kubernetes.ca.crt</span>
</code></pre>
<blockquote class="code-block example">
<p> 禁用对 dev 集群条目的证书检查</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-cluster</span> <span class="hljs-string">e2e </span><span class="hljs-built_in">--insecure-skip-tls-verify=true</span>
</code></pre>
<p>在 kubeconfig 中设置集群条目. </p>
<p>指定已经存在的名称将在这些字段的现有值之上合并新的字段.</p>
<h3 id="usage">用法</h3>
<p><code>$ set-cluster NAME [--server=server] [--certificate-authority=path/to/certificate/authority] [--insecure-skip-tls-verify=true]</code></p>
<h3 id="flags">标记</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>api-version</td>
<td></td>
<td></td>
<td>kubeconfig 中的集群条目的 api 版本 </td>
</tr>
<tr>
<td>certificate-authority</td>
<td></td>
<td></td>
<td>kubeconfig 中的集群条目的证书授权文件的路径 </td>
</tr>
<tr>
<td>embed-certs</td>
<td></td>
<td>false</td>
<td>用于 kubeconfig 中的集群条目的 embed-certs</td>
</tr>
<tr>
<td>insecure-skip-tls-verify</td>
<td></td>
<td>false</td>
<td>对 kubeconfig 中的集群条目进行 insecure-skip-tls 验证 </td>
</tr>
<tr>
<td>server</td>
<td></td>
<td></td>
<td>kubeconfig中的集群条目的服务器</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-set-context-em-"><em>set-context</em></h2>
<blockquote class="code-block example">
<p> 在 gce 上下文条目中设置用户字段，而不触及其他值</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-context</span> <span class="hljs-string">gce </span><span class="hljs-built_in">--user=cluster-admin</span>
</code></pre>
<p>在 kubeconfig 中设置上下文条目 </p>
<p>指定已经存在的名称将在这些字段的现有值之上合并新的字段.</p>
<h3 id="usage">用法</h3>
<p><code>$ set-context NAME [--cluster=cluster_nickname] [--user=user_nickname] [--namespace=namespace]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster</td>
<td></td>
<td></td>
<td>用于 kubeconfig 中的上下文条目的集群 </td>
</tr>
<tr>
<td>namespace</td>
<td></td>
<td></td>
<td>kubeconfig 中上下文条目的命名空间 </td>
</tr>
<tr>
<td>user</td>
<td></td>
<td></td>
<td>用户为 kubeconfig 中的上下文条目 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-set-credentials-em-"><em>set-credentials</em></h2>
<blockquote class="code-block example">
<p> 仅设置 “client-key” “cluster-admin” 字段条目，不触及其他值：</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-credentials</span> <span class="hljs-string">cluster-admin </span><span class="hljs-built_in">--client-key=~/.kube/admin.key</span>
</code></pre>
<blockquote class="code-block example">
<p> 为 “cluster-admin” 设置基本身份验证条目</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-credentials</span> <span class="hljs-string">cluster-admin </span><span class="hljs-built_in">--username=admin</span> <span class="hljs-built_in">--password=uXFGweU9l35qcif</span>
</code></pre>
<blockquote class="code-block example">
<p> 将客户端证书数据嵌入到 “cluster-admin” 条目</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-credentials</span> <span class="hljs-string">cluster-admin </span><span class="hljs-built_in">--client-certificate=~/.kube/admin.crt</span> <span class="hljs-built_in">--embed-certs=true</span>
</code></pre>
<blockquote class="code-block example">
<p> 启用 Google Compute Platform 验证服务提供商的 “cluster-admin” 条目</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-credentials</span> <span class="hljs-string">cluster-admin </span><span class="hljs-built_in">--auth-provider=gcp</span>
</code></pre>
<blockquote class="code-block example">
<p> 为 “cluster-admin” 启用 OpenID Connect auth 提供程序，具有附加参数的条目</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-credentials</span> <span class="hljs-string">cluster-admin </span><span class="hljs-built_in">--auth-provider=oidc</span> <span class="hljs-built_in">--auth-provider-arg=client-id=foo</span> <span class="hljs-built_in">--auth-provider-arg=client-secret=bar</span>
</code></pre>
<blockquote class="code-block example">
<p> 删除 “client-secret” “cluster-admin” 的 OpenID Connect auth 提供程序的配置值条目</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-string">kubectl </span><span class="hljs-string">config </span><span class="hljs-built_in">set-credentials</span> <span class="hljs-string">cluster-admin </span><span class="hljs-built_in">--auth-provider=oidc</span> <span class="hljs-built_in">--auth-provider-arg=client-secret-</span>
</code></pre>
<p>设置 kubeconfig 中的用户条目 </p>
<p>指定已经存在的名称将在现有的值之上合并新的字段. </p>
<p>  客户端证书标志：
  --client-certificate=certfile --client-key=keyfile</p>
<p>  承载令牌标志：
    --token=bearer_token</p>
<p>  Basic auth flags:
    --username=basic_user --password=basic_password</p>
<p>承载令牌和基本认证是相互排斥的.</p>
<h3 id="usage">用法</h3>
<p><code>$ set-credentials NAME [--client-certificate=path/to/certfile] [--client-key=path/to/keyfile] [--token=bearer_token] [--username=basic_user] [--password=basic_password] [--auth-provider=provider_name] [--auth-provider-arg=key=value]</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>auth-provider</td>
<td></td>
<td></td>
<td>kubeconfig 中用户条目的验证提供程序 </td>
</tr>
<tr>
<td>auth-provider-arg</td>
<td></td>
<td>[]</td>
<td>oauth 提供者的 'key = value' 参数 </td>
</tr>
<tr>
<td>client-certificate</td>
<td></td>
<td></td>
<td>kubeconfig 中用户条目的客户端证书文件的路径 </td>
</tr>
<tr>
<td>client-key</td>
<td></td>
<td></td>
<td>kubeconfig中用户条目的客户端密钥文件的路径 </td>
</tr>
<tr>
<td>embed-certs</td>
<td></td>
<td>false</td>
<td>在 kubeconfig 中嵌入用户条目的客户端证书/密钥 </td>
</tr>
<tr>
<td>password</td>
<td></td>
<td></td>
<td>kubeconfig 中用户条目的密码 </td>
</tr>
<tr>
<td>token</td>
<td></td>
<td></td>
<td>kubeconfig 中用户条目的令牌 </td>
</tr>
<tr>
<td>username</td>
<td></td>
<td></td>
<td>kubeconfig 中的用户条目的用户名 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-em-unset-em-"><em>unset</em></h2>
<p>在 kubeconfig 文件中取消单个值 </p>
<p>PROPERTY _NAME 是一个点分隔的名称，其中每个标记表示属性名称或地图键.地图键可能不包含点.</p>
<h3 id="usage">用法</h3>
<p><code>$ unset PROPERTY_NAME</code></p>
<hr>
<h2 id="-em-use-context-em-"><em>use-context</em></h2>
<p>Sets the current-context in a kubeconfig file</p>
<h3 id="usage">标示</h3>
<p><code>$ use-context CONTEXT_NAME</code></p>
<hr>
<h2 id="-em-view-em-"><em>view</em></h2>
<blockquote class="code-block example">
<p> 显示合并的 kubeconfig 设置.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">config</span> view
</code></pre>
<blockquote class="code-block example">
<p> 获取 e2e 用户的密码</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">config</span> view -o <span class="hljs-keyword">jsonpath='{.users[?(@.name </span>== <span class="hljs-string">"e2e"</span>)].user.password}<span class="hljs-string">'</span>
</code></pre>
<p>显示合并的 kubeconfig 设置或指定的 kubeconfig 文件. </p>
<p>您可以使用 --output jsonpath = {...} 使用 jsonpath 表达式提取特定值.</p>
<h3 id="usage">用法</h3>
<p><code>$ view</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>flatten</td>
<td></td>
<td>false</td>
<td>将生成的 kubeconfig 文件压缩为独立输出（可用于创建便携式 kubeconfig 文件） </td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td>true</td>
<td>合并 kubeconfig 文件的完整层次结构 </td>
</tr>
<tr>
<td>minify</td>
<td></td>
<td>false</td>
<td>从输出中删除当前上下文不使用的所有信息 </td>
</tr>
<tr>
<td>no-headers</td>
<td></td>
<td>false</td>
<td>使用默认或自定义列输出格式时，不打印标题. </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出格式. 其中之一：json | yaml | wide | name | custom-columns = ... | custom-columns-file = ... | go-template = ... | go-template-file = ... | jsonpath = ... | jsonpath-file = ...查看自定义列 [<a href="http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns">http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns</a>], golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>] 和 jsonpath 模板 [<a href="http://kubernetes.io/docs/user-guide/jsonpath">http://kubernetes.io/docs/user-guide/jsonpath</a>]. </td>
</tr>
<tr>
<td>output-version</td>
<td></td>
<td></td>
<td>输出具有给定组版本的格式化对象（例如：“extensions / v1beta1”）. </td>
</tr>
<tr>
<td>raw</td>
<td></td>
<td>false</td>
<td>显示原始字节数据 </td>
</tr>
<tr>
<td>show-all</td>
<td>a</td>
<td>false</td>
<td>打印时，显示所有资源（默认隐藏终止的 pod）. </td>
</tr>
<tr>
<td>show-labels</td>
<td></td>
<td>false</td>
<td>打印时，将所有标签显示为最后一列（默认隐藏标签列） </td>
</tr>
<tr>
<td>sort-by</td>
<td></td>
<td></td>
<td>如果非空，则使用此字段规范排序列表类型. 字段规范表示为 JSONPath 表达式（例如 “{.metadata.name}”）. 由此 JSONPath 表达式指定的 API 资源中的字段必须是整数或字符串. </td>
</tr>
<tr>
<td>template</td>
<td></td>
<td></td>
<td>-o = go-template，-o = go-template-file 中使用模板文件的模板字符串或路径. 模板格式是 golang 模板 [<a href="http://golang.org/pkg/text/template/#pkg-overview">http://golang.org/pkg/text/template/#pkg-overview</a>]. </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="explain">explain</h1>
<blockquote class="code-block example">
<p> 获取资源及其字段的文档</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell"><span class="hljs-attribute">kubectl explain pods</span>
</code></pre>
<blockquote class="code-block example">
<p> 获取资源的特定字段的文档</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl explain pods<span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.containers</span>
</code></pre>
<p>资源记录. </p>
<p>有效的资源类型包括：</p>
<ul>
<li>clusters (仅适用于联邦 apiservers)  </li>
<li>componentstatuses (又名 &#39;cs&#39;)  </li>
<li>configmaps (又名 &#39;cm&#39;)  </li>
<li>daemonsets (又名 &#39;ds&#39;)  </li>
<li>deployments (又名 &#39;deploy&#39;)  </li>
<li>endpoints (又名 &#39;ep&#39;)  </li>
<li>events (又名 &#39;ev&#39;)  </li>
<li>horizontalpodautoscalers (又名 &#39;hpa&#39;)  </li>
<li>ingresses (又名 &#39;ing&#39;)  </li>
<li>jobs  </li>
<li>limitranges (又名 &#39;limits&#39;)  </li>
<li>namespaces (又名 &#39;ns&#39;)  </li>
<li>networkpolicies  </li>
<li>nodes (又名 &#39;no&#39;)  </li>
<li>persistentvolumeclaims (又名 &#39;pvc&#39;)  </li>
<li>persistentvolumes (又名 &#39;pv&#39;)  </li>
<li>pods (又名 &#39;po&#39;)  </li>
<li>podsecuritypolicies (又名 &#39;psp&#39;)  </li>
<li>podtemplates  </li>
<li>replicasets (又名 &#39;rs&#39;)  </li>
<li>replicationcontrollers (又名 &#39;rc&#39;)  </li>
<li>resourcequotas (又名 &#39;quota&#39;)  </li>
<li>secrets  </li>
<li>serviceaccounts (又名 &#39;sa&#39;)  </li>
<li>services (又名 &#39;svc&#39;)  </li>
<li>statefulsets  </li>
<li>storageclasses  </li>
<li>thirdpartyresources</li>
</ul>
<h3 id="usage">用法</h3>
<p><code>$ explain RESOURCE</code></p>
<h3 id="flags">标记</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>标记</th>
</tr>
</thead>
<tbody>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新API的定义. [默认为 true]</td>
</tr>
<tr>
<td>recursive</td>
<td></td>
<td>false</td>
<td>打印字段的字段(当前仅为1级) </td>
</tr>
</tbody>
</table>
<hr>
<h1 id="options">options</h1>
<h3 id="usage">用法</h3>
<p><code>$ options</code></p>
<hr>
<h1 id="version">version</h1>
<h3 id="usage">用法</h3>
<p><code>$ version</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>标示</th>
</tr>
</thead>
<tbody>
<tr>
<td>client</td>
<td>c</td>
<td>false</td>
<td>仅客户端版本（不需要服务器）. </td>
</tr>
<tr>
<td>short</td>
<td></td>
<td>false</td>
<td>打印版本号.</td>
</tr>
</tbody>
</table>


<h1 id="-strong-deprecated-commands-strong-"><strong>弃用命令</strong></h1>
<hr>
<h1 id="stop">stop</h1>
<blockquote class="code-block example">
<p> 关闭 foo.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">stop</span> replicationcontroller foo
</code></pre>
<blockquote class="code-block example">
<p> 停止使用标签 name = myLabel 的 pod 和服务.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-keyword">stop</span> pods,services -l <span class="hljs-keyword">name</span>=myLabel
</code></pre>
<blockquote class="code-block example">
<p> 关闭 service.json 中定义的服务.</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">stop</span> -f service.json
</code></pre>
<blockquote class="code-block example">
<p>关闭在 path/to/resources 目录中的所有资源</p>
</blockquote>
<pre class="code-block example"><code class="lang-shell">kubectl <span class="hljs-built_in">stop</span> -f path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">resources</span>
</code></pre>
<p>已弃用：此命令已弃用，其所有功能都被 “kubectl delete” 覆盖.</p>
<h3 id="usage">用法</h3>
<p><code>$ stop (-f FILENAME | TYPE (NAME | -l label | --all))</code></p>
<h3 id="flags">标示</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>简称</th>
<th>默认</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td></td>
<td>false</td>
<td>[-all] 选择所有指定的资源. </td>
</tr>
<tr>
<td>filename</td>
<td>f</td>
<td>[]</td>
<td>要停止的资源的文件名，目录或 URL. </td>
</tr>
<tr>
<td>grace-period</td>
<td></td>
<td>-1</td>
<td>一段时间之后，给资源以优雅的终止.如果负忽视. </td>
</tr>
<tr>
<td>ignore-not-found</td>
<td></td>
<td>false</td>
<td>把 &quot;resource not found&quot; 作为一个成功的停止的信号 </td>
</tr>
<tr>
<td>include-extended-apis</td>
<td></td>
<td>true</td>
<td>如果为 true，则通过调用 API 服务器来包含新 API 的定义. [默认为 true] </td>
</tr>
<tr>
<td>output</td>
<td>o</td>
<td></td>
<td>输出模式.使用 “-o name” 用于较短的输出（资源/名称）. </td>
</tr>
<tr>
<td>recursive</td>
<td>R</td>
<td>false</td>
<td>以递归方式处理 -f，--filename 中使用的目录. 当您想要管理在同一目录中组织的相关清单时很有用. </td>
</tr>
<tr>
<td>selector</td>
<td>l</td>
<td></td>
<td>选择器（标签查询）进行过滤. </td>
</tr>
<tr>
<td>timeout</td>
<td></td>
<td>0s</td>
<td>在放弃删除之前等待的时间长度，零表示从对象的大小确定超时 </td>
</tr>
</tbody>
</table>
</div>
</div>
<script src="node_modules/jquery/dist/jquery.min.js"></script>
<script src="node_modules/jquery.scrollto/jquery.scrollTo.min.js"></script>
<script src="navData.js"></script>
<script src="scroll.js"></script>

<script src="tabvisibility.js"></script>
</body>
</html>














